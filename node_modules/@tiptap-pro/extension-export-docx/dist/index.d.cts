import { JSONContent, Extension } from '@tiptap/core';
import { Paragraph, Table, TextRun, IStylesOptions, PositiveUniversalMeasure, UniversalMeasure, Header, Footer, Math, IParagraphOptions, TableCell, TableRow, ExternalHyperlink } from 'docx';
import * as docx from 'docx';
export { docx as Docx };
import { Stream } from 'stream';

type ConvertConfig = {
    node: Node;
    customNodes?: CustomNode[];
    styleOverrides?: IStylesOptions;
    /**
     * The size of the page in universal measure.
     *
     * You can use the following units: cm, in, pt, pc, mm, px.
     * @param options.pageSize.width - The width of the page, default is "21.0cm"
     * @param options.pageSize.height - The height of the page, default is "29.7cm"
     * @default { width: "21.0cm", height: "29.7cm" }
     */
    pageSize?: {
        /**
         * The width of the page, default is "21.0cm"
         *
         * You can use the following units: cm, in, pt, pc, mm, px.
         * @default "21.0cm"
         * @type {PositiveUniversalMeasure}
         */
        width?: PositiveUniversalMeasure;
        /**
         * The height of the page, default is "29.7cm"
         *
         * You can use the following units: cm, in, pt, pc, mm, px.
         * @default "29.7cm"
         * @type {PositiveUniversalMeasure}
         */
        height?: PositiveUniversalMeasure;
    };
    /**
     * The margins of the page in universal measure.
     * You can use the following units: cm, in, pt, pc, mm, px.
     * @param options.pageMargins.top - The top margin of the page, default is "1.0cm"
     * @param options.pageMargins.bottom - The bottom margin of the page, default is "1.0cm"
     * @param options.pageMargins.left - The left margin of the page, default is "1.0cm"
     * @param options.pageMargins.right - The right margin of the page, default is "1.0cm"
     * @default { top: "1.0cm", bottom: "1.0cm", left: "1.0cm", right: "1.0cm" }
     */
    pageMargins?: {
        /**
         * The top margin of the page, default is "1.0cm".
         *
         * You can use the following units: cm, in, pt, pc, mm, px.
         *
         * Can be negative.
         * @default "1.0cm"
         * @type {UniversalMeasure}
         */
        top?: UniversalMeasure;
        /**
         * The bottom margin of the page, default is "1.0cm"
         *
         * You can use the following units: cm, in, pt, pc, mm, px.
         *
         * Can be negative.
         * @default "1.0cm"
         * @type {UniversalMeasure}
         */
        bottom?: UniversalMeasure;
        /**
         * The left margin of the page, default is "1.0cm"
         *
         * You can use the following units: cm, in, pt, pc, mm, px.
         * @default "1.0cm"
         * @type {PositiveUniversalMeasure}
         */
        left?: PositiveUniversalMeasure;
        /**
         * The right margin of the page, default is "1.0cm"
         *
         * You can use the following units: cm, in, pt, pc, mm, px.
         * @default "1.0cm"
         * @type {PositiveUniversalMeasure}
         */
        right?: PositiveUniversalMeasure;
    };
    headers?: {
        evenAndOddHeaders?: boolean;
        default?: Header | (() => Promise<Header>);
        first?: Header | (() => Promise<Header>);
        even?: Header | (() => Promise<Header>);
    };
    footers?: {
        evenAndOddFooters?: boolean;
        default?: Footer | (() => Promise<Footer>);
        first?: Footer | (() => Promise<Footer>);
        even?: Footer | (() => Promise<Footer>);
    };
};
interface Mark {
    type: string;
    attrs?: {
        [key: string]: any;
    };
}
interface Node extends JSONContent {
}
interface CustomNode {
    type: string;
    render: (node: Node) => Paragraph | Paragraph[] | Table | TextRun | null;
}
interface ImageDimensions {
    width: number;
    height: number;
}
interface ConvertExtensions {
    id: string;
    [key: symbol]: unknown;
}
interface HeaderFooterExtensionConfig {
    allowedHeadersAndFooters: boolean;
}
interface HeaderFooterExtensions extends ConvertExtensions {
    [key: symbol]: HeaderFooterExtensionConfig;
}

type ExportDocxOptions$1 = {
    document: JSONContent;
    exportType: 'buffer' | 'string' | 'base64' | 'blob' | 'stream';
    customNodes: CustomNode[];
    styleOverrides: IStylesOptions;
    /**
     * The size of the page in universal measure.
     *
     * You can use the following units: cm, in, pt, pc, mm, px.
     * @param options.pageSize.width - The width of the page, default is "21.0cm"
     * @param options.pageSize.height - The height of the page, default is "29.7cm"
     * @default { width: "21.0cm", height: "29.7cm" }
     */
    pageSize?: {
        /**
         * The width of the page, default is "21.0cm"
         *
         * You can use the following units: cm, in, pt, pc, mm, px.
         * @default "21.0cm"
         * @type {PositiveUniversalMeasure}
         */
        width?: PositiveUniversalMeasure;
        /**
         * The height of the page, default is "29.7cm"
         *
         * You can use the following units: cm, in, pt, pc, mm, px.
         * @default "29.7cm"
         * @type {PositiveUniversalMeasure}
         */
        height?: PositiveUniversalMeasure;
    };
    /**
     * The margins of the page in universal measure.
     * You can use the following units: cm, in, pt, pc, mm, px.
     * @param options.pageMargins.top - The top margin of the page, default is "1.0cm"
     * @param options.pageMargins.bottom - The bottom margin of the page, default is "1.0cm"
     * @param options.pageMargins.left - The left margin of the page, default is "1.0cm"
     * @param options.pageMargins.right - The right margin of the page, default is "1.0cm"
     * @default { top: "1.0cm", bottom: "1.0cm", left: "1.0cm", right: "1.0cm" }
     */
    pageMargins?: {
        /**
         * The top margin of the page, default is "1.0cm".
         *
         * You can use the following units: cm, in, pt, pc, mm, px.
         *
         * Can be negative.
         * @default "1.0cm"
         * @type {UniversalMeasure}
         */
        top?: UniversalMeasure;
        /**
         * The bottom margin of the page, default is "1.0cm"
         *
         * You can use the following units: cm, in, pt, pc, mm, px.
         *
         * Can be negative.
         * @default "1.0cm"
         * @type {UniversalMeasure}
         */
        bottom?: UniversalMeasure;
        /**
         * The left margin of the page, default is "1.0cm"
         *
         * You can use the following units: cm, in, pt, pc, mm, px.
         * @default "1.0cm"
         * @type {PositiveUniversalMeasure}
         */
        left?: PositiveUniversalMeasure;
        /**
         * The right margin of the page, default is "1.0cm"
         *
         * You can use the following units: cm, in, pt, pc, mm, px.
         * @default "1.0cm"
         * @type {PositiveUniversalMeasure}
         */
        right?: PositiveUniversalMeasure;
    };
    /**
     * Headers for the exported document
     */
    headers?: {
        /**
         * Whether to use different headers for odd and even pages
         */
        evenAndOddHeaders?: boolean;
        /**
         * The standard default header on every page or header on odd pages when the 'evenAndOddHeaders' option is activated
         */
        default?: Header | (() => Promise<Header>);
        /**
         * // The header on first page when the 'Different First Page' option is activated
         */
        first?: Header | (() => Promise<Header>);
        /**
         * The header on even pages when the 'evenAndOddHeaders' option is activated
         */
        even?: Header | (() => Promise<Header>);
    };
    /**
     * Footers for the exported document
     */
    footers?: {
        /**
         * Whether to use different footers for odd and even pages
         */
        evenAndOddFooters?: boolean;
        /**
         * The standard default footer on every page or footer on odd pages when the 'evenAndOddHeaders' option is activated
         */
        default?: Footer | (() => Promise<Footer>);
        /**
         * The footer on first page when the 'Different First Page' option is activated
         */
        first?: Footer | (() => Promise<Footer>);
        /**
         * The footer on even pages when the 'evenAndOddHeaders' option is activated
         */
        even?: Footer | (() => Promise<Footer>);
    };
    /**
     * Extensions to use for the exported document.
     *
     * @example
     * ```ts
     * import { DocxHeaderFooterExtension } from '@tiptap-pro/extension-export-docx-header-footer'
     *
     * const docx = await exportDocx({
     *   extensions: [DocxHeaderFooterExtension],
     * })
     * ```
     *
     * @default []
     */
    extensions?: ConvertExtensions[];
};
/**
 * Export the current document as a .docx file
 *
 * Notes: 'buffer' and 'stream' export types are only available in the server environment
 * as they use the Node Buffer and Stream APIs respectively
 *
 * @param options - Export options
 * @param options.document - The JSON representation of the document
 * @param options.exportType - The type of export to perform
 * @param options.customNodes - Custom node definitions
 * @param options.styleOverrides - Style overrides for the exported document
 * @param options.headers - Headers for the exported document
 * @param options.footers - Footers for the exported document
 * @param options.extensions - Extensions to use for the exported document
 * @example exportDocx({ document: editor.getJSON(), exportType: 'buffer', customNodes: [], styleOverrides: {}, headers: { default: new Paragraph({ text: 'Header' }) }, footers: { default: new Paragraph({ text: 'Footer' }) } })
 */
declare const exportDocx: ({ document, exportType, customNodes, styleOverrides, pageSize, pageMargins, headers, footers, extensions, }: ExportDocxOptions$1) => Promise<string | Buffer<ArrayBufferLike> | Blob | Stream>;

/**
 * Export Docx Options
 * Export type Stream is only available in the server environment
 */
interface ExportDocxOptions extends ExportDocxOptions$1 {
    /**
     * Callback function to handle the exported file
     * @param result - The exported file in the chosen format
     * @returns void
     */
    onCompleteExport: (result: Buffer | string | Blob | Stream) => void;
    /**
     * Export type. Buffer and Stream are only available in the server environment
     */
    exportType: 'buffer' | 'string' | 'base64' | 'blob' | 'stream';
}
declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        ['export-docx']: {
            /**
             * Export the current document as a .docx file
             *
             * Notes: 'buffer' and 'stream' export types are only available in the server environment
             * as they use the Node Buffer and Stream APIs respectively
             *
             * @param onCompleteExport - Callback function to handle the exported file
             * @param exportType - The type of export to perform
             * @param customNodes - Custom node definitions - Client side only
             * @param styleOverrides - Style overrides for the exported document
             * @example editor.commands.exportDocx({onCompleteExport: (result) => {}, exportType: 'buffer', customNodes: [], styleOverrides: {} })
             *
             */
            exportDocx: (options?: ExportDocxOptions) => ReturnType;
        };
    }
}
declare const ExportDocx: Extension<Omit<ExportDocxOptions, "document">, any>;

type ConvertFooterOptions = {
    node: Node;
};
/**
 * Converts a node to DOCX header node.
 */
declare function convertFooter({ node }: ConvertFooterOptions): Promise<Footer>;

type ConvertHeaderOptions = {
    node: Node;
};
/**
 * Converts a node to DOCX header node.
 */
declare function convertHeader({ node }: ConvertHeaderOptions): Promise<Header>;

type ConvertHeadingOptions = {
    node: Node;
    customNodes: CustomNode[];
};
/**
 * Converts a heading node.
 * A heading node is a paragraph node with a different style.
 */
declare function convertHeading({ node, customNodes }: ConvertHeadingOptions): Promise<Paragraph | Paragraph[]>;

declare const convertHorizontalRule: () => Paragraph;

type ConvertImageOptions = {
    node: Node;
};
/**
 * Converts an image JSON node into a DOCX Paragraph containing an ImageRun.
 *
 * The JSON node is expected to have:
 *   - type: 'image'
 *   - attrs: { src: string }
 *
 * This function:
 *   1. Fetches the image data from the provided URL.
 *   2. Determines the intrinsic dimensions of the image (either using an HTMLImageElement in the browser or image-size in Node).
 *   3. Converts these pixel dimensions to points.
 *   4. Creates an ImageRun with the computed dimensions.
 */
declare function convertImage({ node }: ConvertImageOptions): Promise<Paragraph>;

type ConvertBulletListOptions = {
    node: Node;
    customNodes: CustomNode[];
    level?: number;
};
/**
 * Converts an unordered (bullet) list node.
 * Accepts an optional `level` (default 0) for nested lists.
 */
declare function convertBulletList({ node, customNodes, level, }: ConvertBulletListOptions): Promise<Paragraph[]>;

type ConvertListItemOptions = {
    item: Node;
    listType: 'bullet' | 'ordered';
    level?: number;
    orderedListInstanceId?: number;
    customNodes: CustomNode[];
};
/**
 * Converts a list item node.
 * Accepts a `listType` ('bullet' or 'ordered') and a `level` (default 0).
 */
declare function convertListItem({ item, listType, level, orderedListInstanceId, customNodes, }: ConvertListItemOptions): Promise<Paragraph[]>;

type ConvertOrderedListOptions = {
    node: Node;
    customNodes: CustomNode[];
    level?: number;
};
/**
 * Converts an ordered list node.
 * Accepts an optional `level` (default 0) for nested lists.
 */
declare function convertOrderedList({ node, customNodes, level, }: ConvertOrderedListOptions): Promise<Paragraph[]>;

/**
 * Converts a block math node to a docx Paragraph with LaTeX content
 *
 * @param node - The block math node containing LaTeX content
 * @returns Paragraph with LaTeX content or null
 */
declare function convertBlockMath({ node }: {
    node: Node;
}): Paragraph | null;

/**
 * Converts an inline math node to a Math element with LaTeX content.
 *
 * @param node - The inline math node containing LaTeX content
 * @returns Math element with LaTeX content or null
 */
declare function convertInlineMath(node: Node): Math | null;

/**
 * Generic conversion function for a Prosemirror node to a docx document.
 *
 * It will try to automatically detect the node type and convert it to the appropriate DOCX node.
 *
 * If the node type is not supported, it will return an empty array.
 *
 * @params {ConvertConfig} config
 * @params {Node} config.node - Prosemirror node
 * @oarams {CustomNode[]} config.customNodes - Custom node definitions - Client side only
 * @returns Promise<Document | Paragraph | Paragraph[] | Table | null>
 */
declare function convertNode({ node, customNodes, pageSize, pageMargins, }: ConvertConfig): Promise<Paragraph | Paragraph[] | Table | TextRun | null>;

type ParagraphListOptions = {
    type: 'bullet' | 'ordered';
    level?: number;
    orderedListInstanceId?: number;
};
type ConvertParagraphOptions = {
    node: Node;
    customNodes: CustomNode[];
    options?: IParagraphOptions;
    list?: ParagraphListOptions;
};
/**
 * Converts a paragraph node into one or more DOCX Paragraphs.
 * When options?.style is provided (e.g. "Quote"), returns a single paragraph
 * with that style. Otherwise, handles embedded images by converting them separately.
 */
declare function convertParagraph({ node, customNodes, options, list, }: ConvertParagraphOptions): Promise<Paragraph | Paragraph[]>;

type ConvertQuoteOptions = {
    node: Node;
    customNodes: CustomNode[];
};
/**
 * Converts a blockquote node into an array of Paragraphs that have the "Quote" style.
 *
 * Assumes that a blockquote's content is a list of paragraph nodes.
 */
declare function convertQuote({ node, customNodes }: ConvertQuoteOptions): Promise<Paragraph[]>;

type ConvertTableOptions = {
    node: Node;
    customNodes: CustomNode[];
    pageSize: ConvertConfig['pageSize'];
    pageMargins: ConvertConfig['pageMargins'];
};
/**
 * Converts a JSON table node into a DOCX Table.
 * Expects node.type === "table" and node.content to be an array of tableRow nodes.
 */
declare function convertTable({ node, customNodes, pageSize, pageMargins }: ConvertTableOptions): Promise<Table>;

type ConvertTableCellOptions = {
    node: Node;
    customNodes: CustomNode[];
    columnWidthPercentage?: number;
    columnWidthTwips?: number;
    totalColumns?: number;
};
/**
 * Converts a JSON table cell node (tableCell or tableHeader) into a DOCX TableCell.
 * Expects node.type === "tableCell" or "tableHeader".
 * Currently, only colspan is supported.
 */
declare function convertTableCell({ node, customNodes, columnWidthPercentage, columnWidthTwips, totalColumns, }: ConvertTableCellOptions): Promise<TableCell>;

type ConvertTableRowOptions = {
    node: Node;
    customNodes: CustomNode[];
};
/**
 * Converts a JSON tableRow node into a DOCX TableRow.
 * Expects node.type === "tableRow" and node.content to be an array of cell nodes.
 */
declare function convertTableRow({ node, customNodes }: ConvertTableRowOptions): Promise<TableRow>;

/**
 * Converts a text JSON node into a TextRun (or wraps it in an ExternalHyperlink if needed)
 */
declare function convertTextNode(node: Node): TextRun | ExternalHyperlink;

/**
 * Converts a line height value (in lines) to the value measured in 240ths of a line,
 * which is what Word expects.
 *
 * @param {number} lineHeight - The desired line height in terms of lines (e.g., 1 for single, 1.5 for one and a half).
 * @returns {number} The corresponding value in 240ths of a line.
 */
declare function lineHeightToDocx(lineHeight: number): number;

/**
 * This function converts pixels to half points
 * The standard conversion is 1px ≈ 0.75pt.
 * However, Word uses half points, so we multiply by 2.
 * @param pixels number
 * @returns docx half points of the given pixels
 */
declare function pixelsToHalfPoints(pixels: number): number;

/**
 * This function converts pixels to points
 * The standard conversion is 1px ≈ 0.75pt.
 * @param pixels number
 * @returns docx half points of the given pixels
 */
declare function pixelsToPoints(pixels: number): number;

/**
 * Converts a font size in points to half-points.
 * In docx, font sizes are specified in half-points.
 * For example, 11pt becomes 22.
 *
 * @param {number} points - The font size in points.
 * @returns {number} The font size in half-points.
 */
declare function pointsToHalfPoints(points: number): number;

/**
 * Converts a value in points to twips (1 point = 20 twips).
 *
 * @param {number} points - The value in points.
 * @returns {number} The value in twips.
 */
declare function pointsToTwips(points: number): number;

export { type ConvertConfig, type ConvertExtensions, type CustomNode, ExportDocx, type HeaderFooterExtensionConfig, type HeaderFooterExtensions, type ImageDimensions, type Mark, type Node, convertBlockMath, convertBulletList, convertFooter, convertHeader, convertHeading, convertHorizontalRule, convertImage, convertInlineMath, convertListItem, convertNode, convertOrderedList, convertParagraph, convertQuote, convertTable, convertTableCell, convertTableRow, convertTextNode, exportDocx, lineHeightToDocx, pixelsToHalfPoints, pixelsToPoints, pointsToHalfPoints, pointsToTwips };
