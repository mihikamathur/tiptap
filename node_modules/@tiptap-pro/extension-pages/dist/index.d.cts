import * as _tiptap_core from '@tiptap/core';
import { Extension, Editor } from '@tiptap/core';
import { TableKitOptions } from '@tiptap/extension-table';
import { Node } from '@tiptap/pm/model';
import { EditorView } from '@tiptap/pm/view';

declare const TableKit: _tiptap_core.Extension<TableKitOptions, any>;

interface PageKitOptions {
    pages: PagesOptions;
    table: TableKitOptions | false;
}
declare const PageKit: Extension<PageKitOptions, any>;

interface PageNodeInfo {
    node: Node;
    pos: number;
    page: number;
}
/**
 * Stateless page tracker that calculates which nodes belong to which pages on-demand.
 * No caching, no state synchronization issues - just pure calculations.
 */
declare class PageTracker {
    /**
     * Get all nodes on a specific page (calculated fresh each time)
     */
    getNodesOnPage(pageNumber: number, view: EditorView): PageNodeInfo[];
    /**
     * Get the page number for a given document position
     */
    getPageForPosition(pos: number, view: EditorView, debug?: boolean): number;
    /**
     * Get the page for the current selection in the editor
     */
    getCurrentPage(view: EditorView, debug?: boolean): number;
    /**
     * Get the total number of pages
     */
    getPageCount(view: EditorView): number;
    /**
     * Get all page numbers that have content
     */
    getPages(view: EditorView): number[];
    /**
     * Check if a specific position range spans multiple pages
     */
    doesRangeSpanPages(from: number, to: number, view: EditorView): {
        spans: boolean;
        pages: number[];
    };
    /**
     * Get summary statistics about page distribution
     */
    getPageStats(view: EditorView): {
        totalPages: number;
        totalNodes: number;
        nodesPerPage: {
            [pageNumber: number]: number;
        };
        averageNodesPerPage: number;
    };
    /**
     * Get all nodes across all pages with their page information
     */
    getAllNodesWithPages(view: EditorView): PageNodeInfo[];
    /**
     * Find the closest node to a given position on the same page
     */
    getClosestNodeOnSamePage(targetPos: number, view: EditorView): PageNodeInfo | undefined;
    /**
     * Get page break positions in document-relative coordinates
     */
    private getPageBreakPositions;
    /**
     * Calculate which page a position belongs to (without needing specific node)
     */
    private calculatePageForPosition;
    /**
     * Calculate which page a specific node belongs to
     */
    private calculateNodePage;
    /**
     * Fallback estimation for positions outside viewport
     */
    private estimatePageForPosition;
    /**
     * Fallback estimation for nodes outside viewport
     */
    private estimateNodePage;
    /**
     * Get all nodes for documents without pagination
     */
    private getAllNodesOnSinglePage;
}

declare const PAGE_FORMATS: {
    readonly A4: {
        readonly id: "A4";
        readonly width: number;
        readonly height: number;
        readonly margins: {
            readonly top: number;
            readonly right: number;
            readonly bottom: number;
            readonly left: number;
        };
    };
    readonly A3: {
        readonly id: "A3";
        readonly width: number;
        readonly height: number;
        readonly margins: {
            readonly top: number;
            readonly right: number;
            readonly bottom: number;
            readonly left: number;
        };
    };
    readonly A5: {
        readonly id: "A5";
        readonly width: number;
        readonly height: number;
        readonly margins: {
            readonly top: number;
            readonly right: number;
            readonly bottom: number;
            readonly left: number;
        };
    };
    readonly Letter: {
        readonly id: "Letter";
        readonly width: number;
        readonly height: number;
        readonly margins: {
            readonly top: number;
            readonly right: number;
            readonly bottom: number;
            readonly left: number;
        };
    };
    readonly Legal: {
        readonly id: "Legal";
        readonly width: number;
        readonly height: number;
        readonly margins: {
            readonly top: number;
            readonly right: number;
            readonly bottom: number;
            readonly left: number;
        };
    };
    readonly Tabloid: {
        readonly id: "Tabloid";
        readonly width: number;
        readonly height: number;
        readonly margins: {
            readonly top: number;
            readonly right: number;
            readonly bottom: number;
            readonly left: number;
        };
    };
};
type PageFormat = keyof typeof PAGE_FORMATS | CustomPageFormat;
type PageMargins = {
    top: number;
    right: number;
    bottom: number;
    left: number;
};
type CustomPageFormat = {
    id: string;
    width: number;
    height: number;
    margins: PageMargins;
};

type PagesHeaderFooter = ((pageNumber: number, totalPages: number) => string) | string;
type HeaderType = 'default' | 'first' | 'odd' | 'even';
type FooterType = 'default' | 'first' | 'odd' | 'even';
interface PagesStorage {
    pageFormat: PageFormat;
    footer: PagesHeaderFooter;
    header: PagesHeaderFooter;
    headerHTML: string;
    pageGap: number;
    headerTopMargin: number | undefined;
    headerContentHeight: number;
    headerFirstPageContentHeight: number;
    headerOddContentHeight: number;
    headerEvenContentHeight: number;
    normalizedHeaderTemplate: string | null;
    differentFirstPage: boolean;
    headerFirstPage: PagesHeaderFooter;
    headerFirstPageHTML: string;
    normalizedFirstPageTemplate: string | null;
    differentOddEven: boolean;
    headerOdd: PagesHeaderFooter;
    headerEven: PagesHeaderFooter;
    headerOddHTML: string;
    headerEvenHTML: string;
    normalizedOddTemplate: string | null;
    normalizedEvenTemplate: string | null;
    footerBottomMargin: number | undefined;
    footerHTML: string;
    footerContentHeight: number;
    footerFirstPageContentHeight: number;
    footerOddContentHeight: number;
    footerEvenContentHeight: number;
    normalizedFooterTemplate: string | null;
    differentFirstPageFooter: boolean;
    footerFirstPage: PagesHeaderFooter;
    footerFirstPageHTML: string;
    normalizedFirstPageFooterTemplate: string | null;
    differentOddEvenFooter: boolean;
    footerOdd: PagesHeaderFooter;
    footerEven: PagesHeaderFooter;
    footerOddHTML: string;
    footerEvenHTML: string;
    normalizedOddFooterTemplate: string | null;
    normalizedEvenFooterTemplate: string | null;
    pageBreakBackground: string;
    uniqueId: string;
    styleElement: HTMLStyleElement | null;
    pageTracker: PageTracker;
    /**
     * Active header/footer editor instance when editing.
     * Use this to build custom toolbars or access editor state.
     */
    activeEditor: Editor | null;
    /**
     * Type of the currently active editor ('header' or 'footer').
     */
    activeEditorType: 'header' | 'footer' | null;
    /**
     * Page number of the header/footer being edited.
     */
    activePageNumber: number | null;
    /**
     * Get the current page number.
     * @param debug - If true, will log debug information to the console.
     * @returns The current page number.
     */
    getCurrentPage?: (debug?: boolean) => number;
    getPageForPosition?: (pos: number) => number;
    getNodesOnPage?: (pageNumber: number) => any[];
    getPageStats?: () => any;
    doesRangeSpanPages?: (from: number, to: number) => any;
    getPageCount?: () => number;
}
declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        pages: {
            /**
             * Import a file into your editor and replace the current content.
             */
            setPageFormat: (pageFormat: PageFormat) => ReturnType;
            /**
             * Set the footer text.
             * @param footer - The footer text.
             * @returns True if the footer was set.
             */
            setFooter: (footer: PagesHeaderFooter) => ReturnType;
            /**
             * Set the header text.
             * @param header - The header text.
             * @returns True if the header was set.
             */
            setHeader: (header: PagesHeaderFooter) => ReturnType;
            /**
             * Set the page break background.
             * @param pageBreakBackground - The page break background.
             * @returns True if the page break background was set.
             */
            setPageBreakBackground: (pageBreakBackground: string) => ReturnType;
            /**
             * Set the page gap.
             * @param pageGap - The page gap.
             * @returns True if the page gap was set.
             */
            setPageGap: (pageGap: number) => ReturnType;
            /**
             * Set the header top margin (distance from page edge to content start).
             * @param headerTopMargin - The header top margin.
             * @returns True if the header top margin was set.
             */
            setHeaderTopMargin: (headerTopMargin: number) => ReturnType;
            /**
             * Set the footer bottom margin (distance from content bottom to page edge).
             * @param footerBottomMargin - The footer bottom margin.
             * @returns True if the footer bottom margin was set.
             */
            setFooterBottomMargin: (footerBottomMargin: number) => ReturnType;
            /**
             * Enable or disable different first page header.
             * @param enabled - Whether to enable different first page.
             */
            setDifferentFirstPage: (enabled: boolean) => ReturnType;
            /**
             * Set the header content for the first page.
             * @param header - The first page header content.
             */
            setHeaderFirstPage: (header: PagesHeaderFooter) => ReturnType;
            /**
             * Enable or disable different odd/even page headers.
             * @param enabled - Whether to enable different odd/even headers.
             */
            setDifferentOddEven: (enabled: boolean) => ReturnType;
            /**
             * Set the header content for odd pages.
             * @param header - The odd pages header content.
             */
            setHeaderOdd: (header: PagesHeaderFooter) => ReturnType;
            /**
             * Set the header content for even pages.
             * @param header - The even pages header content.
             */
            setHeaderEven: (header: PagesHeaderFooter) => ReturnType;
            /**
             * Enable or disable different first page footer.
             * @param enabled - Whether to enable different first page footer.
             */
            setDifferentFirstPageFooter: (enabled: boolean) => ReturnType;
            /**
             * Set the footer content for the first page.
             * @param footer - The first page footer content.
             */
            setFooterFirstPage: (footer: PagesHeaderFooter) => ReturnType;
            /**
             * Enable or disable different odd/even page footers.
             * @param enabled - Whether to enable different odd/even footers.
             */
            setDifferentOddEvenFooter: (enabled: boolean) => ReturnType;
            /**
             * Set the footer content for odd pages.
             * @param footer - The odd pages footer content.
             */
            setFooterOdd: (footer: PagesHeaderFooter) => ReturnType;
            /**
             * Set the footer content for even pages.
             * @param footer - The even pages footer content.
             */
            setFooterEven: (footer: PagesHeaderFooter) => ReturnType;
            /**
             * Get the current page number based on the selection.
             * @returns The current page number.
             */
            getCurrentPage: () => ReturnType;
            /**
             * Get the page number for a specific position in the document.
             * @param pos - The position in the document.
             * @returns The page number.
             */
            getPageForPosition: (pos: number) => ReturnType;
            /**
             * Get all nodes on a specific page.
             * @param pageNumber - The page number.
             * @returns Array of ProseMirror nodes on that page.
             */
            getNodesOnPage: (pageNumber: number) => ReturnType;
            /**
             * Get detailed statistics about page distribution.
             * @returns Statistics object with page information.
             */
            getPageStats: () => ReturnType;
            /**
             * Check if a position range spans multiple pages.
             * @param from - Starting position.
             * @param to - Ending position.
             * @returns Object with span information and affected pages.
             */
            doesRangeSpanPages: (from: number, to: number) => ReturnType;
        };
    }
    interface Storage {
        pages: PagesStorage;
    }
}
interface PagesOptions {
    /**
     * Accepts a built-in page format key (e.g. 'A4', 'Letter') or a custom page format object.
     */
    pageFormat: PageFormat;
    /**
     * Distance from page edge to header content start (in pixels).
     * Defaults to 50% of margins.top (matches Word's 0.5" default).
     */
    headerTopMargin?: number;
    /**
     * Distance from footer content bottom to page edge (in pixels).
     * Defaults to 50% of margins.bottom.
     */
    footerBottomMargin?: number;
    pageGap?: number;
    footer: PagesHeaderFooter;
    header: PagesHeaderFooter;
    /**
     * Enable different header for first page.
     */
    differentFirstPage?: boolean;
    /**
     * Header content for first page (when differentFirstPage is true).
     */
    headerFirstPage?: PagesHeaderFooter;
    /**
     * Enable different headers for odd/even pages.
     */
    differentOddEven?: boolean;
    /**
     * Header content for odd pages (when differentOddEven is true).
     */
    headerOdd?: PagesHeaderFooter;
    /**
     * Header content for even pages (when differentOddEven is true).
     */
    headerEven?: PagesHeaderFooter;
    /**
     * Enable different footer for first page.
     */
    differentFirstPageFooter?: boolean;
    /**
     * Footer content for first page (when differentFirstPageFooter is true).
     */
    footerFirstPage?: PagesHeaderFooter;
    /**
     * Enable different footers for odd/even pages.
     */
    differentOddEvenFooter?: boolean;
    /**
     * Footer content for odd pages (when differentOddEvenFooter is true).
     */
    footerOdd?: PagesHeaderFooter;
    /**
     * Footer content for even pages (when differentOddEvenFooter is true).
     */
    footerEven?: PagesHeaderFooter;
    pageBreakBackground?: string;
    onPageFormatChange?: (pageFormat: PageFormat) => void;
    /**
     * Extensions to use for the header/footer editor.
     * Defaults to StarterKit if not provided.
     */
    headerFooterExtensions?: Extension[];
}
declare const Pages: Extension<PagesOptions, PagesStorage>;

/**
 * Convert centimeters to pixels based on DPI
 * @param cm - Value in centimeters
 * @param dpi - Dots per inch (default: auto-detected DPI)
 * @returns Value in pixels
 */
declare function cmToPixels(cm: number, dpi?: number): number;

/**
 * Converts inches to pixels, given a DPI (dots per inch).
 * @param inches - The value in inches to convert.
 * @param dpi - The dots per inch (default 96).
 * @returns The value in pixels.
 */
declare function inchToPixels(inches: number, dpi?: number): number;

export { type CustomPageFormat, type FooterType, type HeaderType, PAGE_FORMATS, type PageFormat, PageKit, Pages, type PagesHeaderFooter, type PagesOptions, TableKit, cmToPixels, inchToPixels };
