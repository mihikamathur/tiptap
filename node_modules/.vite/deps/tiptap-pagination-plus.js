import {
  AddMarkStep,
  AttrStep,
  Decoration,
  DecorationSet,
  Extension,
  Plugin,
  PluginKey,
  RemoveMarkStep,
  RemoveNodeMarkStep,
  ReplaceAroundStep,
  ReplaceStep
} from "./chunk-BI5E4KEG.js";
import "./chunk-G3PMV62Z.js";

// node_modules/tiptap-pagination-plus/dist/utils.js
var updateCssVariables = (targetNode, config) => {
  const cssVariables = {
    "rm-page-height": `${config.pageHeight}px`,
    "rm-margin-top": `${config.marginTop}px`,
    "rm-margin-bottom": `${config.marginBottom}px`,
    "rm-margin-left": `${config.marginLeft}px`,
    "rm-margin-right": `${config.marginRight}px`,
    "rm-content-margin-top": `${config.contentMarginTop}px`,
    "rm-content-margin-bottom": `${config.contentMarginBottom}px`,
    "rm-page-gap-border-color": `${config.pageGapBorderColor}`,
    "rm-page-width": `${config.pageWidth}px`
  };
  Object.entries(cssVariables).forEach(([key2, value]) => {
    targetNode.style.setProperty(`--${key2}`, value);
  });
};
var getPageSize = (height, width, marginTop, marginBottom, marginLeft, marginRight) => {
  return {
    pageHeight: height,
    pageWidth: width,
    marginTop,
    marginBottom,
    marginLeft,
    marginRight
  };
};
var getHeaderHeight = (targetNode, pageNumbers, type) => {
  const headerHeightMap = /* @__PURE__ */ new Map();
  const clientHeader = targetNode.querySelector(getHeaderHeightSelector(0, type));
  headerHeightMap.set(0, clientHeader ? clientHeader.clientHeight : 0);
  pageNumbers.forEach((pageNumber) => {
    const clientHeader2 = targetNode.querySelector(getHeaderHeightSelector(pageNumber, type));
    const headerHeight = clientHeader2 ? clientHeader2.clientHeight : 0;
    headerHeightMap.set(pageNumber, headerHeight);
  });
  return headerHeightMap;
};
var getHeaderHeightSelector = (pageNumber, type) => {
  return type === "actual" ? `.rm-page-header-${pageNumber}` : `.rm-page-header-${pageNumber} .rm-page-header-content`;
};
var getFooterHeight = (targetNode, pageNumbers, type) => {
  const footerHeightMap = /* @__PURE__ */ new Map();
  const clientFooter = targetNode.querySelector(getFooterHeightSelector(0, type));
  footerHeightMap.set(0, clientFooter ? clientFooter.clientHeight : 0);
  pageNumbers.forEach((pageNumber) => {
    const clientFooter2 = targetNode.querySelector(getFooterHeightSelector(pageNumber, type));
    const footerHeight = clientFooter2 ? clientFooter2.clientHeight : 0;
    footerHeightMap.set(pageNumber, footerHeight);
  });
  return footerHeightMap;
};
var getFooterHeightSelector = (pageNumber, type) => {
  return type === "actual" ? `.rm-page-footer-${pageNumber}` : `.rm-page-footer-${pageNumber} .rm-page-footer-content`;
};
function deepEqualIterative(a, b) {
  if (a === b)
    return true;
  if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {
    return false;
  }
  const stack = [{ x: a, y: b }];
  while (stack.length) {
    const _stackItem = stack.pop();
    if (!_stackItem)
      continue;
    const { x, y } = _stackItem;
    if (x === y)
      continue;
    if (typeof x !== typeof y)
      return false;
    if (typeof x !== "object")
      return false;
    if (x == null || y == null)
      return false;
    const xKeys = Object.keys(x);
    const yKeys = Object.keys(y);
    if (xKeys.length !== yKeys.length)
      return false;
    for (const key2 of xKeys) {
      if (!(key2 in y))
        return false;
      const xVal = x[key2];
      const yVal = y[key2];
      if (xVal === yVal)
        continue;
      if (typeof xVal === "object" && typeof yVal === "object") {
        stack.push({ x: xVal, y: yVal });
      } else {
        if (xVal !== yVal)
          return false;
      }
    }
  }
  return true;
}
function getCustomPages(customHeader, customFooter) {
  return [...Object.keys(customHeader), ...Object.keys(customFooter)].map(Number);
}
function getFooter(footerRightContent, footerLeftContent, onFooterClick, pageNumber) {
  const pageFooter = document.createElement("div");
  pageFooter.classList.add("rm-page-footer");
  pageFooter.classList.add(`rm-page-footer-${pageNumber ? pageNumber : 0}`);
  pageFooter.style.overflow = "visible";
  pageFooter.style.position = "relative";
  pageFooter.style.cursor = "pointer";
  const pageFooterContent = document.createElement("div");
  pageFooterContent.classList.add("rm-page-footer-content");
  pageFooterContent.style.width = "100%";
  pageFooterContent.style.overflow = "hidden";
  const footerRight = footerRightContent.replace("{page}", `<span class="rm-page-number"></span>`);
  const footerLeft = footerLeftContent.replace("{page}", `<span class="rm-page-number"></span>`);
  const pageFooterLeft = document.createElement("div");
  pageFooterLeft.classList.add("rm-page-footer-left");
  pageFooterLeft.innerHTML = footerLeft;
  const pageFooterRight = document.createElement("div");
  pageFooterRight.classList.add("rm-page-footer-right");
  pageFooterRight.innerHTML = footerRight;
  pageFooterContent.append(pageFooterLeft, pageFooterRight);
  pageFooter.append(pageFooterContent);
  pageFooter.addEventListener("click", onFooterClick);
  return pageFooter;
}
function getHeader(headerRightContent, headerLeftContent, onHeaderClick, pageNumber) {
  const pageHeader = document.createElement("div");
  pageHeader.classList.add("rm-page-header");
  pageHeader.classList.add(`rm-page-header-${pageNumber ? pageNumber : 0}`);
  pageHeader.style.overflow = "hidden";
  pageHeader.style.cursor = "pointer";
  pageHeader.style.position = "relative";
  const pageHeaderContent = document.createElement("div");
  pageHeaderContent.classList.add("rm-page-header-content");
  pageHeaderContent.style.width = "100%";
  pageHeaderContent.style.overflow = "hidden";
  const headerLeft = headerLeftContent.replace("{page}", `<span class="rm-page-number-plus"></span>`);
  const headerRight = headerRightContent.replace("{page}", `<span class="rm-page-number-plus"></span>`);
  const pageHeaderLeft = document.createElement("div");
  pageHeaderLeft.classList.add("rm-page-header-left");
  pageHeaderLeft.innerHTML = headerLeft;
  const pageHeaderRight = document.createElement("div");
  pageHeaderRight.classList.add("rm-page-header-right");
  pageHeaderRight.innerHTML = headerRight;
  pageHeaderContent.append(pageHeaderLeft, pageHeaderRight);
  pageHeader.append(pageHeaderContent);
  pageHeader.addEventListener("click", onHeaderClick);
  return pageHeader;
}
var getHeight = (pageOptions, _headerHeight, _footerHeight) => {
  const _pageHeaderHeight = pageOptions.contentMarginTop + pageOptions.marginTop + _headerHeight;
  const _pageFooterHeight = pageOptions.contentMarginBottom + pageOptions.marginBottom + _footerHeight;
  const _pageHeight = pageOptions.pageHeight - _pageHeaderHeight - _pageFooterHeight;
  return {
    _pageHeaderHeight,
    _pageFooterHeight,
    _pageHeight
  };
};
var headerClickEvent = (pageNumber, onHeaderClick) => {
  return (event) => {
    onHeaderClick === null || onHeaderClick === void 0 ? void 0 : onHeaderClick({
      event,
      pageNumber
    });
  };
};
var footerClickEvent = (pageNumber, onFooterClick) => {
  return (event) => {
    onFooterClick === null || onFooterClick === void 0 ? void 0 : onFooterClick({
      event,
      pageNumber
    });
  };
};

// node_modules/tiptap-pagination-plus/dist/PaginationPlus.js
var page_count_meta_key = "PAGE_COUNT_META_KEY";
var key = new PluginKey("brDecoration");
function buildDecorations(doc) {
  const decorations = [];
  doc.descendants((node, pos) => {
    if (node.type.name === "hardBreak") {
      const afterPos = pos + 1;
      const widget = Decoration.widget(afterPos, () => {
        const el = document.createElement("span");
        el.classList.add("rm-br-decoration");
        return el;
      });
      decorations.push(widget);
    }
  });
  return DecorationSet.create(doc, decorations);
}
var defaultOptions = {
  pageHeight: 800,
  pageWidth: 789,
  pageGap: 50,
  pageGapBorderSize: 1,
  pageBreakBackground: "#ffffff",
  footerRight: "{page}",
  footerLeft: "",
  headerRight: "",
  headerLeft: "",
  marginTop: 20,
  marginBottom: 20,
  marginLeft: 50,
  marginRight: 50,
  contentMarginTop: 10,
  contentMarginBottom: 10,
  pageGapBorderColor: "#e5e5e5",
  customHeader: {},
  customFooter: {}
};
var refreshPage = (targetNode) => {
  var _a;
  const paginationElement = targetNode.querySelector("[data-rm-pagination]");
  if (paginationElement) {
    const lastPageBreak = (_a = paginationElement.lastElementChild) === null || _a === void 0 ? void 0 : _a.querySelector(".breaker");
    if (lastPageBreak) {
      const minHeight = lastPageBreak.offsetTop + lastPageBreak.offsetHeight;
      targetNode.style.minHeight = `calc(${minHeight}px + 2px)`;
    }
  }
};
var paginationKey = new PluginKey("pagination");
var PaginationPlus = Extension.create({
  name: "PaginationPlus",
  addOptions() {
    return defaultOptions;
  },
  addStorage() {
    return Object.assign(Object.assign({}, defaultOptions), { headerHeight: /* @__PURE__ */ new Map(), footerHeight: /* @__PURE__ */ new Map() });
  },
  onCreate() {
    const targetNode = this.editor.view.dom;
    targetNode.classList.add("rm-with-pagination");
    targetNode.style.border = `1px solid var(--rm-page-gap-border-color)`;
    targetNode.style.paddingLeft = `var(--rm-margin-left)`;
    targetNode.style.paddingRight = `var(--rm-margin-right)`;
    targetNode.style.width = `var(--rm-page-width)`;
    updateCssVariables(targetNode, this.options);
    const style = document.createElement("style");
    style.dataset.rmPaginationStyle = "";
    style.textContent = `
      .rm-pagination-gap{
        border-top: 1px solid;
        border-bottom: 1px solid;
        border-color: var(--rm-page-gap-border-color);
      }
      .rm-with-pagination,
      .rm-with-pagination .rm-first-page-header {
        counter-reset: page-number page-number-plus 1;
      }
      .rm-with-pagination .image-plus-wrapper,
      .rm-with-pagination .table-plus td,
      .rm-with-pagination .table-plus th {
        max-height: var(--rm-max-content-child-height);
        overflow-y: auto;
      }
      .rm-with-pagination .image-plus-wrapper {
        overflow-y: visible;
      }
      .rm-with-pagination .rm-page-break {
        counter-increment: page-number page-number-plus;
      }
      
      .rm-with-pagination .rm-page-break:last-child .rm-pagination-gap {
        display: none;
      }
      .rm-with-pagination .rm-page-break:last-child .rm-page-header {
        display: none;
      }
      
      .rm-with-pagination table tr td,
      .rm-with-pagination table tr th {
        word-break: break-all;
      }
      .rm-with-pagination table > tr {
        display: grid;
        min-width: 100%;
      }
      .rm-with-pagination table {
        border-collapse: collapse;
        width: 100%;
        display: contents;
      }
      .rm-with-pagination table tbody{
        display: table;
        max-height: 300px;
        overflow-y: auto;
      }
      .rm-with-pagination table tbody > tr{
        display: table-row !important;
      }
      .rm-with-pagination *:has(>br.ProseMirror-trailingBreak:only-child) {
        display: table;
        width: 100%;
      }
      .rm-with-pagination .rm-br-decoration {
        display: table;
        width: 100%;
      }
      .rm-with-pagination .table-row-group {
        max-height: var(--rm-max-content-child-height);
        overflow-y: auto;
        width: 100%;
      }
      .rm-with-pagination .rm-page-footer-left,
      .rm-with-pagination .rm-page-footer-right,
      .rm-with-pagination .rm-page-header-left,
      .rm-with-pagination .rm-page-header-right {
        display: inline-block;
      }
      
      .rm-with-pagination .rm-page-header-left,
      .rm-with-pagination .rm-page-footer-left{
        float: left;
        margin-left: var(--rm-margin-left);
      }
      .rm-with-pagination .rm-page-header-right,
      .rm-with-pagination .rm-page-footer-right{
        float: right;
        margin-right: var(--rm-margin-right);
      }
      .rm-with-pagination .rm-first-page-header .rm-page-header-right{
        margin-right: 0px !important;
      }
      .rm-with-pagination .rm-first-page-header .rm-page-header-left{
        margin-left: 0px !important;
      }
      .rm-with-pagination .rm-page-number::before {
        content: counter(page-number);
      }
      .rm-with-pagination .rm-page-number-plus::before {
        content: counter(page-number-plus);
      }
      .rm-with-pagination .rm-page-header,
      .rm-with-pagination .rm-page-footer{
        width: 100%;
      }
      .rm-with-pagination .rm-page-header{
        padding-bottom: var(--rm-content-margin-top) !important;
        padding-top: var(--rm-margin-top) !important;
        display: inline-flex;
        justify-content: space-between;
        max-height: calc(calc(var(--rm-page-height) * 0.45) - var(--rm-margin-top) - var(--rm-content-margin-top));
        overflow-y: hidden;
      }
      .rm-with-pagination .rm-page-footer{
        padding-top: var(--rm-content-margin-bottom) !important;
        padding-bottom: var(--rm-margin-bottom) !important;
        display: inline-flex;
        justify-content: space-between;
        max-height: calc(calc(var(--rm-page-height) * 0.45) - var(--rm-content-margin-bottom) - var(--rm-margin-bottom));
        overflow-y: hidden;
      }
    `;
    document.head.appendChild(style);
    refreshPage(targetNode);
  },
  addProseMirrorPlugins() {
    const editor = this.editor;
    return [
      new Plugin({
        key: paginationKey,
        state: {
          init: (_, state) => {
            const widgetList = createDecoration(this.options, /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map());
            this.storage = Object.assign(Object.assign({}, this.options), { headerHeight: /* @__PURE__ */ new Map(), footerHeight: /* @__PURE__ */ new Map() });
            return {
              decorations: DecorationSet.create(state.doc, widgetList)
            };
          },
          apply: (tr, oldDeco, oldState, newState) => {
            const pageCount = calculatePageCount(editor.view, this.options);
            const currentPageCount = getExistingPageCount(editor.view);
            const getNewDecoration = () => {
              updateCssVariables(editor.view.dom, this.options);
              let headerHeight = "headerHeight" in this.storage ? this.storage.headerHeight : /* @__PURE__ */ new Map();
              let footerHeight = "footerHeight" in this.storage ? this.storage.footerHeight : /* @__PURE__ */ new Map();
              const widgetList = createDecoration(this.options, headerHeight, footerHeight);
              this.storage = Object.assign(Object.assign({}, this.options), { headerHeight, footerHeight });
              return {
                decorations: DecorationSet.create(newState.doc, [...widgetList]),
                footerHeight
              };
            };
            if ((pageCount > 1 ? pageCount : 1) !== currentPageCount || this.storage.pageBreakBackground !== this.options.pageBreakBackground || this.storage.pageHeight !== this.options.pageHeight || this.storage.pageWidth !== this.options.pageWidth || this.storage.marginTop !== this.options.marginTop || this.storage.marginBottom !== this.options.marginBottom || this.storage.marginLeft !== this.options.marginLeft || this.storage.marginRight !== this.options.marginRight || this.storage.pageGap !== this.options.pageGap || this.storage.contentMarginTop !== this.options.contentMarginTop || this.storage.contentMarginBottom !== this.options.contentMarginBottom || this.storage.headerLeft !== this.options.headerLeft || this.storage.headerRight !== this.options.headerRight || this.storage.footerLeft !== this.options.footerLeft || this.storage.footerRight !== this.options.footerRight || !deepEqualIterative(this.options.customHeader, this.storage.customHeader) || !deepEqualIterative(this.options.customFooter, this.storage.customFooter)) {
              return getNewDecoration();
            }
            return oldDeco;
          }
        },
        props: {
          decorations(state) {
            var _a;
            return (_a = this.getState(state)) === null || _a === void 0 ? void 0 : _a.decorations;
          }
        },
        view: (editorView) => {
          return {
            update: (view) => {
              const pageCount = calculatePageCount(view, this.options);
              const currentPageCount = getExistingPageCount(view);
              const triggerUpdate = (_footerHeight) => {
                requestAnimationFrame(() => {
                  const tr = view.state.tr.setMeta(page_count_meta_key, { footerHeight: _footerHeight });
                  view.dispatch(tr);
                });
              };
              if (currentPageCount !== pageCount) {
                triggerUpdate();
                return;
              }
              const headerHeight = getHeaderHeight(view.dom, getCustomPages(this.options.customHeader, {}), "content");
              const footerHeight = getFooterHeight(view.dom, getCustomPages({}, this.options.customFooter), "content");
              const footerHeightForCurrentPages = /* @__PURE__ */ new Map();
              for (let i = 0; i <= pageCount; i++) {
                if (footerHeight.has(i)) {
                  footerHeightForCurrentPages.set(i, footerHeight.get(i) || 0);
                }
              }
              const headerHeightForCurrentPages = /* @__PURE__ */ new Map();
              for (let i = 0; i <= pageCount; i++) {
                if (headerHeight.has(i)) {
                  headerHeightForCurrentPages.set(i, headerHeight.get(i) || 0);
                }
              }
              const pagesSetToCheck = /* @__PURE__ */ new Set([1, ...footerHeightForCurrentPages.keys(), ...headerHeightForCurrentPages.keys()]);
              let missingPageNumber = void 0;
              for (let i = 1; i <= pageCount; i++) {
                if (!pagesSetToCheck.has(i)) {
                  missingPageNumber = i;
                  break;
                }
              }
              if (missingPageNumber) {
                pagesSetToCheck.add(missingPageNumber);
              }
              pagesSetToCheck.delete(0);
              let pageContentHeightVariable = {};
              let maxContentHeight = void 0;
              for (const page of pagesSetToCheck) {
                const headerHeight2 = headerHeightForCurrentPages.has(page) ? headerHeightForCurrentPages.get(page) || 0 : headerHeightForCurrentPages.get(0) || 0;
                const footerHeight2 = footerHeightForCurrentPages.has(page) ? footerHeightForCurrentPages.get(page) || 0 : footerHeightForCurrentPages.get(0) || 0;
                const { _pageHeaderHeight, _pageHeight } = getHeight(this.options, headerHeight2, footerHeight2);
                const contentHeight = page === 1 ? _pageHeight + _pageHeaderHeight : _pageHeight;
                if (page === 1) {
                  pageContentHeightVariable[`rm-page-content-first`] = `${contentHeight}px`;
                }
                if (page === missingPageNumber) {
                  pageContentHeightVariable[`rm-page-content-general`] = `${contentHeight}px`;
                } else {
                  pageContentHeightVariable[`rm-page-content-${page}`] = `${contentHeight}px`;
                }
                if (maxContentHeight === void 0 || contentHeight < maxContentHeight) {
                  maxContentHeight = contentHeight;
                }
              }
              if (maxContentHeight) {
                view.dom.style.setProperty(`--rm-max-content-child-height`, `${maxContentHeight - 10}px`);
              }
              Object.entries(pageContentHeightVariable).forEach(([key2, value]) => {
                view.dom.style.setProperty(`--${key2}`, value);
              });
              refreshPage(view.dom);
              return;
            }
          };
        }
      }),
      new Plugin({
        key,
        state: {
          init(_, state) {
            return buildDecorations(state.doc);
          },
          apply(tr, old) {
            if (tr.docChanged || tr.steps.some((step) => step instanceof ReplaceStep) || tr.steps.some((step) => step instanceof ReplaceAroundStep) || tr.steps.some((step) => step instanceof AddMarkStep) || tr.steps.some((step) => step instanceof RemoveMarkStep) || tr.steps.some((step) => step instanceof RemoveNodeMarkStep) || tr.steps.some((step) => step instanceof AttrStep)) {
              return buildDecorations(tr.doc);
            }
            return old;
          }
        },
        props: {
          decorations(state) {
            var _a;
            return (_a = key.getState(state)) !== null && _a !== void 0 ? _a : DecorationSet.empty;
          }
        }
      })
    ];
  },
  addCommands() {
    return {
      updatePageBreakBackground: (color) => () => {
        this.options.pageBreakBackground = color;
        return true;
      },
      updatePageSize: (size) => () => {
        this.options.pageHeight = size.pageHeight;
        this.options.pageWidth = size.pageWidth;
        this.options.marginTop = size.marginTop;
        this.options.marginBottom = size.marginBottom;
        this.options.marginLeft = size.marginLeft;
        this.options.marginRight = size.marginRight;
        return true;
      },
      updatePageWidth: (width) => () => {
        this.options.pageWidth = width;
        return true;
      },
      updatePageHeight: (height) => () => {
        this.options.pageHeight = height;
        return true;
      },
      updatePageGap: (gap) => () => {
        this.options.pageGap = gap;
        return true;
      },
      updateMargins: (margins) => () => {
        this.options.marginTop = margins.top;
        this.options.marginBottom = margins.bottom;
        this.options.marginLeft = margins.left;
        this.options.marginRight = margins.right;
        return true;
      },
      updateContentMargins: (margins) => () => {
        this.options.contentMarginTop = margins.top;
        this.options.contentMarginBottom = margins.bottom;
        return true;
      },
      updateHeaderContent: (left, right, pageNumber) => () => {
        if (pageNumber) {
          this.options.customHeader = Object.assign(Object.assign({}, this.options.customHeader), { [pageNumber]: { headerLeft: left, headerRight: right } });
        } else {
          this.options.headerLeft = left;
          this.options.headerRight = right;
        }
        return true;
      },
      updateFooterContent: (left, right, pageNumber) => () => {
        if (pageNumber) {
          this.options.customFooter = Object.assign(Object.assign({}, this.options.customFooter), { [pageNumber]: { footerLeft: left, footerRight: right } });
        } else {
          this.options.footerLeft = left;
          this.options.footerRight = right;
        }
        return true;
      }
    };
  }
});
var getExistingPageCount = (view) => {
  const editorDom = view.dom;
  const paginationElement = editorDom.querySelector("[data-rm-pagination]");
  if (paginationElement) {
    return paginationElement.children.length;
  }
  return 0;
};
var calculatePageCount = (view, pageOptions, headerHeight = 0, footerHeight = 0) => {
  var _a;
  const editorDom = view.dom;
  const _pageHeaderHeight = pageOptions.contentMarginTop + pageOptions.marginTop + headerHeight;
  const _pageFooterHeight = pageOptions.contentMarginBottom + pageOptions.marginBottom + footerHeight;
  const pageContentAreaHeight = pageOptions.pageHeight - _pageHeaderHeight - _pageFooterHeight;
  const paginationElement = editorDom.querySelector("[data-rm-pagination]");
  const currentPageCount = getExistingPageCount(view);
  if (paginationElement) {
    const lastElementOfEditor = editorDom.lastElementChild;
    const lastPageBreak = (_a = paginationElement.lastElementChild) === null || _a === void 0 ? void 0 : _a.querySelector(".breaker");
    if (lastElementOfEditor && lastPageBreak) {
      const lastElementRect = lastElementOfEditor.getBoundingClientRect();
      const lastPageBreakRect = lastPageBreak.getBoundingClientRect();
      const lastPageGap = lastElementRect.bottom - lastPageBreakRect.bottom;
      if (lastPageGap > 0) {
        const addPage = Math.ceil(lastPageGap / pageContentAreaHeight);
        return currentPageCount + addPage;
      } else {
        const lpFrom = -10;
        const lpTo = -(pageOptions.pageHeight - 10);
        if (lastPageGap > lpTo && lastPageGap < lpFrom) {
          return currentPageCount;
        } else if (lastPageGap < lpTo) {
          const pageHeightOnRemove = pageOptions.pageHeight + pageOptions.pageGap;
          const removePage = Math.floor(lastPageGap / pageHeightOnRemove);
          return currentPageCount + removePage;
        } else {
          return currentPageCount;
        }
      }
    }
    return 1;
  } else {
    const editorHeight = editorDom.scrollHeight;
    let pageCount = Math.ceil(editorHeight / pageContentAreaHeight);
    pageCount = pageCount <= 0 ? 1 : pageCount;
    return pageCount;
  }
};
function createDecoration(pageOptions, headerHeightMap, footerHeightMap) {
  const commonHeaderOptions = { headerLeft: pageOptions.headerLeft, headerRight: pageOptions.headerRight };
  const commonFooterOptions = { footerLeft: pageOptions.footerLeft, footerRight: pageOptions.footerRight };
  const pageWidget = Decoration.widget(0, (view) => {
    const _pageGap = pageOptions.pageGap;
    const _pageBreakBackground = pageOptions.pageBreakBackground;
    const el = document.createElement("div");
    el.dataset.rmPagination = "true";
    const pageBreakDefinition = (firstPage, pageHeader, pageFooter, headerHeight, footerHeight, pageNumber) => {
      const { _pageHeaderHeight, _pageHeight } = getHeight(pageOptions, headerHeight, footerHeight);
      const pageContainer = document.createElement("div");
      pageContainer.classList.add("rm-page-break");
      const page = document.createElement("div");
      page.classList.add("page");
      page.style.position = "relative";
      page.style.float = "left";
      page.style.clear = "both";
      const marginTop = firstPage ? `calc(${_pageHeaderHeight}px + ${_pageHeight}px)` : _pageHeight + "px";
      if (pageNumber) {
        page.style.marginTop = `var(--rm-page-content-${pageNumber}, ${marginTop})`;
      } else {
        page.style.marginTop = firstPage ? `var(--rm-page-content-first, ${marginTop})` : `var(--rm-page-content-general, ${marginTop})`;
      }
      const pageBreak = document.createElement("div");
      pageBreak.classList.add("breaker");
      pageBreak.style.width = `calc(100% + var(--rm-margin-left) + var(--rm-margin-right))`;
      pageBreak.style.marginLeft = `calc(-1 * var(--rm-margin-left))`;
      pageBreak.style.marginRight = `calc(-1 * var(--rm-margin-right))`;
      pageBreak.style.position = "relative";
      pageBreak.style.float = "left";
      pageBreak.style.clear = "both";
      pageBreak.style.left = `0px`;
      pageBreak.style.right = `0px`;
      pageBreak.style.zIndex = "2";
      const pageSpace = document.createElement("div");
      pageSpace.classList.add("rm-pagination-gap");
      pageSpace.style.height = _pageGap + "px";
      pageSpace.style.borderLeft = "1px solid";
      pageSpace.style.borderRight = "1px solid";
      pageSpace.style.position = "relative";
      pageSpace.style.setProperty("width", "calc(100% + 2px)", "important");
      pageSpace.style.left = "-1px";
      pageSpace.style.backgroundColor = _pageBreakBackground;
      pageSpace.style.borderLeftColor = _pageBreakBackground;
      pageSpace.style.borderRightColor = _pageBreakBackground;
      pageBreak.append(pageFooter, pageSpace, pageHeader);
      pageContainer.append(page, pageBreak);
      return pageContainer;
    };
    const _headerHeight = headerHeightMap.get(0) || 0;
    const _footerHeight = footerHeightMap.get(0) || 0;
    const fragment = document.createDocumentFragment();
    const pageCount = calculatePageCount(view, pageOptions);
    for (let i = 0; i < pageCount; i++) {
      const pageNumber = i + 1;
      const headerPageNumber = i + 2;
      if (headerPageNumber in pageOptions.customHeader || pageNumber in pageOptions.customFooter || pageNumber in pageOptions.customHeader) {
        let _headerOptions = commonHeaderOptions;
        let _footerOptions = commonFooterOptions;
        let _pageHeaderHeight = _headerHeight;
        let _pageFooterHeight = _footerHeight;
        if (headerPageNumber in pageOptions.customHeader) {
          _headerOptions = pageOptions.customHeader[headerPageNumber] || commonHeaderOptions;
          _pageHeaderHeight = headerHeightMap.get(headerPageNumber) || 0;
        }
        if (pageNumber in pageOptions.customFooter) {
          _footerOptions = pageOptions.customFooter[pageNumber] || commonFooterOptions;
          _pageFooterHeight = footerHeightMap.get(pageNumber) || 0;
        }
        let _pageHeader = getHeader(_headerOptions.headerRight, _headerOptions.headerLeft, headerClickEvent(headerPageNumber, pageOptions.onHeaderClick), headerPageNumber);
        let _pageFooter = getFooter(_footerOptions.footerRight, _footerOptions.footerLeft, footerClickEvent(pageNumber, pageOptions.onFooterClick), pageNumber);
        let pageBreak = pageBreakDefinition(i === 0, _pageHeader, _pageFooter, _pageHeaderHeight, _pageFooterHeight, pageNumber);
        fragment.appendChild(pageBreak);
      } else {
        const __pageHeader = getHeader(commonHeaderOptions.headerRight, commonHeaderOptions.headerLeft, headerClickEvent(headerPageNumber, pageOptions.onHeaderClick));
        const __pageFooter = getFooter(commonFooterOptions.footerRight, commonFooterOptions.footerLeft, footerClickEvent(pageNumber, pageOptions.onFooterClick));
        fragment.appendChild(pageBreakDefinition(i === 0, __pageHeader, __pageFooter, _headerHeight, _footerHeight));
      }
    }
    el.append(fragment);
    el.id = "pages";
    el.classList.add("rm-pages-wrapper");
    return el;
  }, { side: -1 });
  const firstHeaderWidget = Decoration.widget(0, () => {
    const pageNumber = 1;
    let _headerOptions = commonHeaderOptions;
    if (pageNumber in pageOptions.customHeader) {
      _headerOptions = pageOptions.customHeader[pageNumber];
    }
    const el = getHeader(_headerOptions.headerRight, _headerOptions.headerLeft, headerClickEvent(pageNumber, pageOptions.onHeaderClick));
    el.classList.add("rm-first-page-header");
    return el;
  }, { side: -1 });
  return [pageWidget, firstHeaderWidget];
}

// node_modules/tiptap-pagination-plus/dist/constants.js
var A4_PAGE_SIZE = getPageSize(1123, 794, 95, 95, 76, 76);
var A3_PAGE_SIZE = getPageSize(1591, 1123, 95, 95, 76, 76);
var A5_PAGE_SIZE = getPageSize(794, 419, 76, 76, 57, 57);
var LETTER_PAGE_SIZE = getPageSize(1060, 818, 96, 96, 96, 96);
var LEGAL_PAGE_SIZE = getPageSize(1404, 818, 96, 96, 96, 96);
var TABLOID_PAGE_SIZE = getPageSize(1635, 1060, 96, 96, 96, 96);
var PAGE_SIZES = {
  A4: A4_PAGE_SIZE,
  A3: A3_PAGE_SIZE,
  A5: A5_PAGE_SIZE,
  LETTER: LETTER_PAGE_SIZE,
  LEGAL: LEGAL_PAGE_SIZE,
  TABLOID: TABLOID_PAGE_SIZE
};
export {
  PAGE_SIZES,
  PaginationPlus
};
//# sourceMappingURL=tiptap-pagination-plus.js.map
