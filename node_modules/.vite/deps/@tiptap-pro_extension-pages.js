import {
  dropCursor,
  gapCursor,
  h,
  history,
  redo,
  undo
} from "./chunk-VUKZ4MIX.js";
import {
  Table,
  TableCell,
  TableHeader,
  TableKit,
  TableRow
} from "./chunk-Q4GFV42S.js";
import {
  Decoration,
  DecorationSet,
  Editor,
  Extension,
  Mark,
  Node3,
  NodeSelection,
  Plugin,
  PluginKey,
  Selection,
  TextSelection,
  callOrReturn,
  canInsertNode,
  combineTransactionSteps,
  findChildrenInRange,
  getAttributes,
  getChangedRanges,
  getExtensionField,
  getMarksBetween,
  getNodeAtPosition,
  getNodeType,
  isAtEndOfNode,
  isAtStartOfNode,
  isNodeActive,
  isNodeEmpty,
  isNodeSelection,
  markInputRule,
  markPasteRule,
  mergeAttributes,
  nodeInputRule,
  textblockTypeInputRule,
  wrappingInputRule
} from "./chunk-BI5E4KEG.js";
import "./chunk-G3PMV62Z.js";

// node_modules/@tiptap-pro/extension-pages/dist/index.js
var Yt = Table.extend({ content: "tableRow+", renderHTML({ HTMLAttributes: e }) {
  return ["table", mergeAttributes(this.options.HTMLAttributes, e, {}), 0];
} });
var Qt = TableCell.extend({ name: "tableCell", addNodeView() {
  return () => {
    let e = document.createElement("td");
    return { dom: e, contentDOM: e };
  };
} });
var Jt = TableHeader.extend({ name: "tableHeader", renderHTML({ HTMLAttributes: e }) {
  return ["th", mergeAttributes(this.options.HTMLAttributes, e), 0];
} });
var Xt = TableRow.extend({ addNodeView() {
  return ({ node: e }) => {
    let t = document.createElement("tr"), o = e.content.content.map((n) => (n.type.name === "tableCell" || n.type.name === "tableHeader") && n.attrs.colwidth ? `${n.attrs.colwidth}px` : "1fr");
    t.style.display = "grid", t.style.gridTemplateColumns = o.join(" "), t.style.gridTemplateColumns = e.attrs.style;
    let r = () => {
      let n = e.content.content.map((i) => (i.type.name === "tableCell" || i.type.name === "tableHeader") && i.attrs.colwidth ? `${i.attrs.colwidth}px` : "1fr");
      t.style.gridTemplateColumns = n.join(" "), t.style.gridTemplateColumns = e.attrs.style;
    };
    return { dom: t, contentDOM: t, update: () => {
      r();
    } };
  };
} });
var ut = TableKit.extend({ name: "TableKit", addExtensions() {
  let e = [];
  return this.options.table !== false && e.push(Yt.configure(this.options.table)), this.options.tableCell !== false && e.push(Qt.configure(this.options.tableCell)), this.options.tableHeader !== false && e.push(Jt.configure(this.options.tableHeader)), this.options.tableRow !== false && e.push(Xt.configure(this.options.tableRow)), e;
} });
var Or = Extension.create({ name: "PageKit", addExtensions() {
  let e = [pt.configure(this.options.pages)];
  return this.options.table && e.push(ut.configure(this.options.table)), e;
} });
var Rr = /^\s*>\s$/;
var eo = Node3.create({ name: "blockquote", addOptions() {
  return { HTMLAttributes: {} };
}, content: "block+", group: "block", defining: true, parseHTML() {
  return [{ tag: "blockquote" }];
}, renderHTML({ HTMLAttributes: e }) {
  return h("blockquote", { ...mergeAttributes(this.options.HTMLAttributes, e), children: h("slot", {}) });
}, addCommands() {
  return { setBlockquote: () => ({ commands: e }) => e.wrapIn(this.name), toggleBlockquote: () => ({ commands: e }) => e.toggleWrap(this.name), unsetBlockquote: () => ({ commands: e }) => e.lift(this.name) };
}, addKeyboardShortcuts() {
  return { "Mod-Shift-b": () => this.editor.commands.toggleBlockquote() };
}, addInputRules() {
  return [wrappingInputRule({ find: Rr, type: this.type })];
} });
var Dr = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/;
var Br = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g;
var zr = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/;
var $r = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g;
var no = Mark.create({ name: "bold", addOptions() {
  return { HTMLAttributes: {} };
}, parseHTML() {
  return [{ tag: "strong" }, { tag: "b", getAttrs: (e) => e.style.fontWeight !== "normal" && null }, { style: "font-weight=400", clearMark: (e) => e.type.name === this.name }, { style: "font-weight", getAttrs: (e) => /^(bold(er)?|[5-9]\d{2,})$/.test(e) && null }];
}, renderHTML({ HTMLAttributes: e }) {
  return h("strong", { ...mergeAttributes(this.options.HTMLAttributes, e), children: h("slot", {}) });
}, addCommands() {
  return { setBold: () => ({ commands: e }) => e.setMark(this.name), toggleBold: () => ({ commands: e }) => e.toggleMark(this.name), unsetBold: () => ({ commands: e }) => e.unsetMark(this.name) };
}, addKeyboardShortcuts() {
  return { "Mod-b": () => this.editor.commands.toggleBold(), "Mod-B": () => this.editor.commands.toggleBold() };
}, addInputRules() {
  return [markInputRule({ find: Dr, type: this.type }), markInputRule({ find: zr, type: this.type })];
}, addPasteRules() {
  return [markPasteRule({ find: Br, type: this.type }), markPasteRule({ find: $r, type: this.type })];
} });
var Wr = /(^|[^`])`([^`]+)`(?!`)$/;
var Gr = /(^|[^`])`([^`]+)`(?!`)/g;
var io = Mark.create({ name: "code", addOptions() {
  return { HTMLAttributes: {} };
}, excludes: "_", code: true, exitable: true, parseHTML() {
  return [{ tag: "code" }];
}, renderHTML({ HTMLAttributes: e }) {
  return ["code", mergeAttributes(this.options.HTMLAttributes, e), 0];
}, addCommands() {
  return { setCode: () => ({ commands: e }) => e.setMark(this.name), toggleCode: () => ({ commands: e }) => e.toggleMark(this.name), unsetCode: () => ({ commands: e }) => e.unsetMark(this.name) };
}, addKeyboardShortcuts() {
  return { "Mod-e": () => this.editor.commands.toggleCode() };
}, addInputRules() {
  return [markInputRule({ find: Wr, type: this.type })];
}, addPasteRules() {
  return [markPasteRule({ find: Gr, type: this.type })];
} });
var Xr = /^```([a-z]+)?[\s\n]$/;
var Zr = /^~~~([a-z]+)?[\s\n]$/;
var lo = Node3.create({ name: "codeBlock", addOptions() {
  return { languageClassPrefix: "language-", exitOnTripleEnter: true, exitOnArrowDown: true, defaultLanguage: null, enableTabIndentation: false, tabSize: 4, HTMLAttributes: {} };
}, content: "text*", marks: "", group: "block", code: true, defining: true, addAttributes() {
  return { language: { default: this.options.defaultLanguage, parseHTML: (e) => {
    var t;
    let { languageClassPrefix: o } = this.options, i = [...((t = e.firstElementChild) == null ? void 0 : t.classList) || []].filter((s) => s.startsWith(o)).map((s) => s.replace(o, ""))[0];
    return i || null;
  }, rendered: false } };
}, parseHTML() {
  return [{ tag: "pre", preserveWhitespace: "full" }];
}, renderHTML({ node: e, HTMLAttributes: t }) {
  return ["pre", mergeAttributes(this.options.HTMLAttributes, t), ["code", { class: e.attrs.language ? this.options.languageClassPrefix + e.attrs.language : null }, 0]];
}, addCommands() {
  return { setCodeBlock: (e) => ({ commands: t }) => t.setNode(this.name, e), toggleCodeBlock: (e) => ({ commands: t }) => t.toggleNode(this.name, "paragraph", e) };
}, addKeyboardShortcuts() {
  return { "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(), Backspace: () => {
    let { empty: e, $anchor: t } = this.editor.state.selection, o = t.pos === 1;
    return !e || t.parent.type.name !== this.name ? false : o || !t.parent.textContent.length ? this.editor.commands.clearNodes() : false;
  }, Tab: ({ editor: e }) => {
    if (!this.options.enableTabIndentation) return false;
    let { state: t } = e, { selection: o } = t, { $from: r, empty: n } = o;
    if (r.parent.type !== this.type) return false;
    let i = " ".repeat(this.options.tabSize);
    return n ? e.commands.insertContent(i) : e.commands.command(({ tr: s }) => {
      let { from: a, to: l } = o, u = t.doc.textBetween(a, l, `
`, `
`).split(`
`).map((h2) => i + h2).join(`
`);
      return s.replaceWith(a, l, t.schema.text(u)), true;
    });
  }, "Shift-Tab": ({ editor: e }) => {
    if (!this.options.enableTabIndentation) return false;
    let { state: t } = e, { selection: o } = t, { $from: r, empty: n } = o;
    return r.parent.type !== this.type ? false : n ? e.commands.command(({ tr: i }) => {
      var s;
      let { pos: a } = r, l = r.start(), d = r.end(), u = t.doc.textBetween(l, d, `
`, `
`).split(`
`), h2 = 0, m = 0, f = a - l;
      for (let k = 0; k < u.length; k += 1) {
        if (m + u[k].length >= f) {
          h2 = k;
          break;
        }
        m += u[k].length + 1;
      }
      let T = ((s = u[h2].match(/^ */)) == null ? void 0 : s[0]) || "", g = Math.min(T.length, this.options.tabSize);
      if (g === 0) return true;
      let b = l;
      for (let k = 0; k < h2; k += 1) b += u[k].length + 1;
      return i.delete(b, b + g), a - b <= g && i.setSelection(TextSelection.create(i.doc, b)), true;
    }) : e.commands.command(({ tr: i }) => {
      let { from: s, to: a } = o, c = t.doc.textBetween(s, a, `
`, `
`).split(`
`).map((u) => {
        var h2;
        let m = ((h2 = u.match(/^ */)) == null ? void 0 : h2[0]) || "", f = Math.min(m.length, this.options.tabSize);
        return u.slice(f);
      }).join(`
`);
      return i.replaceWith(s, a, t.schema.text(c)), true;
    });
  }, Enter: ({ editor: e }) => {
    if (!this.options.exitOnTripleEnter) return false;
    let { state: t } = e, { selection: o } = t, { $from: r, empty: n } = o;
    if (!n || r.parent.type !== this.type) return false;
    let i = r.parentOffset === r.parent.nodeSize - 2, s = r.parent.textContent.endsWith(`

`);
    return !i || !s ? false : e.chain().command(({ tr: a }) => (a.delete(r.pos - 2, r.pos), true)).exitCode().run();
  }, ArrowDown: ({ editor: e }) => {
    if (!this.options.exitOnArrowDown) return false;
    let { state: t } = e, { selection: o, doc: r } = t, { $from: n, empty: i } = o;
    if (!i || n.parent.type !== this.type || !(n.parentOffset === n.parent.nodeSize - 2)) return false;
    let a = n.after();
    return a === void 0 ? false : r.nodeAt(a) ? e.commands.command(({ tr: d }) => (d.setSelection(Selection.near(r.resolve(a))), true)) : e.commands.exitCode();
  } };
}, addInputRules() {
  return [textblockTypeInputRule({ find: Xr, type: this.type, getAttributes: (e) => ({ language: e[1] }) }), textblockTypeInputRule({ find: Zr, type: this.type, getAttributes: (e) => ({ language: e[1] }) })];
}, addProseMirrorPlugins() {
  return [new Plugin({ key: new PluginKey("codeBlockVSCodeHandler"), props: { handlePaste: (e, t) => {
    if (!t.clipboardData || this.editor.isActive(this.type.name)) return false;
    let o = t.clipboardData.getData("text/plain"), r = t.clipboardData.getData("vscode-editor-data"), n = r ? JSON.parse(r) : void 0, i = n == null ? void 0 : n.mode;
    if (!o || !i) return false;
    let { tr: s, schema: a } = e.state, l = a.text(o.replace(/\r\n?/g, `
`));
    return s.replaceSelectionWith(this.type.create({ language: i }, l)), s.selection.$from.parent.type !== this.type && s.setSelection(TextSelection.near(s.doc.resolve(Math.max(0, s.selection.from - 2)))), s.setMeta("paste", true), e.dispatch(s), true;
  } } })];
} });
var co = Node3.create({ name: "doc", topNode: true, content: "block+" });
var uo = Node3.create({ name: "hardBreak", addOptions() {
  return { keepMarks: true, HTMLAttributes: {} };
}, inline: true, group: "inline", selectable: false, linebreakReplacement: true, parseHTML() {
  return [{ tag: "br" }];
}, renderHTML({ HTMLAttributes: e }) {
  return ["br", mergeAttributes(this.options.HTMLAttributes, e)];
}, renderText() {
  return `
`;
}, addCommands() {
  return { setHardBreak: () => ({ commands: e, chain: t, state: o, editor: r }) => e.first([() => e.exitCode(), () => e.command(() => {
    let { selection: n, storedMarks: i } = o;
    if (n.$from.parent.type.spec.isolating) return false;
    let { keepMarks: s } = this.options, { splittableMarks: a } = r.extensionManager, l = i || n.$to.parentOffset && n.$from.marks();
    return t().insertContent({ type: this.name }).command(({ tr: d, dispatch: c }) => {
      if (c && l && s) {
        let u = l.filter((h2) => a.includes(h2.type.name));
        d.ensureMarks(u);
      }
      return true;
    }).run();
  })]) };
}, addKeyboardShortcuts() {
  return { "Mod-Enter": () => this.editor.commands.setHardBreak(), "Shift-Enter": () => this.editor.commands.setHardBreak() };
} });
var po = Node3.create({ name: "heading", addOptions() {
  return { levels: [1, 2, 3, 4, 5, 6], HTMLAttributes: {} };
}, content: "inline*", group: "block", defining: true, addAttributes() {
  return { level: { default: 1, rendered: false } };
}, parseHTML() {
  return this.options.levels.map((e) => ({ tag: `h${e}`, attrs: { level: e } }));
}, renderHTML({ node: e, HTMLAttributes: t }) {
  return [`h${this.options.levels.includes(e.attrs.level) ? e.attrs.level : this.options.levels[0]}`, mergeAttributes(this.options.HTMLAttributes, t), 0];
}, addCommands() {
  return { setHeading: (e) => ({ commands: t }) => this.options.levels.includes(e.level) ? t.setNode(this.name, e) : false, toggleHeading: (e) => ({ commands: t }) => this.options.levels.includes(e.level) ? t.toggleNode(this.name, "paragraph", e) : false };
}, addKeyboardShortcuts() {
  return this.options.levels.reduce((e, t) => ({ ...e, [`Mod-Alt-${t}`]: () => this.editor.commands.toggleHeading({ level: t }) }), {});
}, addInputRules() {
  return this.options.levels.map((e) => textblockTypeInputRule({ find: new RegExp(`^(#{${Math.min(...this.options.levels)},${e}})\\s$`), type: this.type, getAttributes: { level: e } }));
} });
var ho = Node3.create({ name: "horizontalRule", addOptions() {
  return { HTMLAttributes: {} };
}, group: "block", parseHTML() {
  return [{ tag: "hr" }];
}, renderHTML({ HTMLAttributes: e }) {
  return ["hr", mergeAttributes(this.options.HTMLAttributes, e)];
}, addCommands() {
  return { setHorizontalRule: () => ({ chain: e, state: t }) => {
    if (!canInsertNode(t, t.schema.nodes[this.name])) return false;
    let { selection: o } = t, { $to: r } = o, n = e();
    return isNodeSelection(o) ? n.insertContentAt(r.pos, { type: this.name }) : n.insertContent({ type: this.name }), n.command(({ tr: i, dispatch: s }) => {
      var a;
      if (s) {
        let { $to: l } = i.selection, d = l.end();
        if (l.nodeAfter) l.nodeAfter.isTextblock ? i.setSelection(TextSelection.create(i.doc, l.pos + 1)) : l.nodeAfter.isBlock ? i.setSelection(NodeSelection.create(i.doc, l.pos)) : i.setSelection(TextSelection.create(i.doc, l.pos));
        else {
          let c = (a = l.parent.type.contentMatch.defaultType) == null ? void 0 : a.create();
          c && (i.insert(d, c), i.setSelection(TextSelection.create(i.doc, d + 1)));
        }
        i.scrollIntoView();
      }
      return true;
    }).run();
  } };
}, addInputRules() {
  return [nodeInputRule({ find: /^(?:---|—-|___\s|\*\*\*\s)$/, type: this.type })];
} });
var mn = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/;
var fn = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g;
var bn = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/;
var vn = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g;
var fo = Mark.create({ name: "italic", addOptions() {
  return { HTMLAttributes: {} };
}, parseHTML() {
  return [{ tag: "em" }, { tag: "i", getAttrs: (e) => e.style.fontStyle !== "normal" && null }, { style: "font-style=normal", clearMark: (e) => e.type.name === this.name }, { style: "font-style=italic" }];
}, renderHTML({ HTMLAttributes: e }) {
  return ["em", mergeAttributes(this.options.HTMLAttributes, e), 0];
}, addCommands() {
  return { setItalic: () => ({ commands: e }) => e.setMark(this.name), toggleItalic: () => ({ commands: e }) => e.toggleMark(this.name), unsetItalic: () => ({ commands: e }) => e.unsetMark(this.name) };
}, addKeyboardShortcuts() {
  return { "Mod-i": () => this.editor.commands.toggleItalic(), "Mod-I": () => this.editor.commands.toggleItalic() };
}, addInputRules() {
  return [markInputRule({ find: mn, type: this.type }), markInputRule({ find: bn, type: this.type })];
}, addPasteRules() {
  return [markPasteRule({ find: fn, type: this.type }), markPasteRule({ find: vn, type: this.type })];
} });
var yn = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0axi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2";
var Tn = "ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2";
var Tt = "numeric";
var Et = "ascii";
var Pt = "alpha";
var ge = "asciinumeric";
var he = "alphanumeric";
var kt = "domain";
var ko = "emoji";
var En = "scheme";
var Pn = "slashscheme";
var gt = "whitespace";
function kn(e, t) {
  return e in t || (t[e] = []), t[e];
}
function ee(e, t, o) {
  t[Tt] && (t[ge] = true, t[he] = true), t[Et] && (t[ge] = true, t[Pt] = true), t[ge] && (t[he] = true), t[Pt] && (t[he] = true), t[he] && (t[kt] = true), t[ko] && (t[kt] = true);
  for (let r in t) {
    let n = kn(r, o);
    n.indexOf(e) < 0 && n.push(e);
  }
}
function Cn(e, t) {
  let o = {};
  for (let r in t) t[r].indexOf(e) >= 0 && (o[r] = true);
  return o;
}
function R(e = null) {
  this.j = {}, this.jr = [], this.jd = null, this.t = e;
}
R.groups = {};
R.prototype = { accepts() {
  return !!this.t;
}, go(e) {
  let t = this, o = t.j[e];
  if (o) return o;
  for (let r = 0; r < t.jr.length; r++) {
    let n = t.jr[r][0], i = t.jr[r][1];
    if (i && n.test(e)) return i;
  }
  return t.jd;
}, has(e, t = false) {
  return t ? e in this.j : !!this.go(e);
}, ta(e, t, o, r) {
  for (let n = 0; n < e.length; n++) this.tt(e[n], t, o, r);
}, tr(e, t, o, r) {
  r = r || R.groups;
  let n;
  return t && t.j ? n = t : (n = new R(t), o && r && ee(t, o, r)), this.jr.push([e, n]), n;
}, ts(e, t, o, r) {
  let n = this, i = e.length;
  if (!i) return n;
  for (let s = 0; s < i - 1; s++) n = n.tt(e[s]);
  return n.tt(e[i - 1], t, o, r);
}, tt(e, t, o, r) {
  r = r || R.groups;
  let n = this;
  if (t && t.j) return n.j[e] = t, t;
  let i = t, s, a = n.go(e);
  if (a ? (s = new R(), Object.assign(s.j, a.j), s.jr.push.apply(s.jr, a.jr), s.jd = a.jd, s.t = a.t) : s = new R(), i) {
    if (r) if (s.t && typeof s.t == "string") {
      let l = Object.assign(Cn(s.t, r), o);
      ee(i, l, r);
    } else o && ee(i, o, r);
    s.t = i;
  }
  return n.j[e] = s, s;
} };
var y = (e, t, o, r, n) => e.ta(t, o, r, n);
var L = (e, t, o, r, n) => e.tr(t, o, r, n);
var bo = (e, t, o, r, n) => e.ts(t, o, r, n);
var p = (e, t, o, r, n) => e.tt(t, o, r, n);
var W = "WORD";
var Ct = "UWORD";
var Co = "ASCIINUMERICAL";
var Ho = "ALPHANUMERICAL";
var Te = "LOCALHOST";
var Ht = "TLD";
var xt = "UTLD";
var Me = "SCHEME";
var ae = "SLASH_SCHEME";
var Mt = "NUM";
var Lt = "WS";
var wt = "NL";
var me = "OPENBRACE";
var fe = "CLOSEBRACE";
var we = "OPENBRACKET";
var Oe = "CLOSEBRACKET";
var Ae = "OPENPAREN";
var Fe = "CLOSEPAREN";
var Se = "OPENANGLEBRACKET";
var Re = "CLOSEANGLEBRACKET";
var Ne = "FULLWIDTHLEFTPAREN";
var Ie = "FULLWIDTHRIGHTPAREN";
var De = "LEFTCORNERBRACKET";
var Be = "RIGHTCORNERBRACKET";
var ze = "LEFTWHITECORNERBRACKET";
var $e = "RIGHTWHITECORNERBRACKET";
var _e = "FULLWIDTHLESSTHAN";
var je = "FULLWIDTHGREATERTHAN";
var Ue = "AMPERSAND";
var Ke = "APOSTROPHE";
var We = "ASTERISK";
var Y = "AT";
var Ge = "BACKSLASH";
var Ve = "BACKTICK";
var qe = "CARET";
var Q = "COLON";
var Ot = "COMMA";
var Ye = "DOLLAR";
var z = "DOT";
var Qe = "EQUALS";
var At = "EXCLAMATION";
var D = "HYPHEN";
var be = "PERCENT";
var Je = "PIPE";
var Xe = "PLUS";
var Ze = "POUND";
var ve = "QUERY";
var Ft = "QUOTE";
var xo = "FULLWIDTHMIDDLEDOT";
var St = "SEMI";
var $ = "SLASH";
var ye = "TILDE";
var et = "UNDERSCORE";
var Lo = "EMOJI";
var tt = "SYM";
var Mo = Object.freeze({ __proto__: null, ALPHANUMERICAL: Ho, AMPERSAND: Ue, APOSTROPHE: Ke, ASCIINUMERICAL: Co, ASTERISK: We, AT: Y, BACKSLASH: Ge, BACKTICK: Ve, CARET: qe, CLOSEANGLEBRACKET: Re, CLOSEBRACE: fe, CLOSEBRACKET: Oe, CLOSEPAREN: Fe, COLON: Q, COMMA: Ot, DOLLAR: Ye, DOT: z, EMOJI: Lo, EQUALS: Qe, EXCLAMATION: At, FULLWIDTHGREATERTHAN: je, FULLWIDTHLEFTPAREN: Ne, FULLWIDTHLESSTHAN: _e, FULLWIDTHMIDDLEDOT: xo, FULLWIDTHRIGHTPAREN: Ie, HYPHEN: D, LEFTCORNERBRACKET: De, LEFTWHITECORNERBRACKET: ze, LOCALHOST: Te, NL: wt, NUM: Mt, OPENANGLEBRACKET: Se, OPENBRACE: me, OPENBRACKET: we, OPENPAREN: Ae, PERCENT: be, PIPE: Je, PLUS: Xe, POUND: Ze, QUERY: ve, QUOTE: Ft, RIGHTCORNERBRACKET: Be, RIGHTWHITECORNERBRACKET: $e, SCHEME: Me, SEMI: St, SLASH: $, SLASH_SCHEME: ae, SYM: tt, TILDE: ye, TLD: Ht, UNDERSCORE: et, UTLD: xt, UWORD: Ct, WORD: W, WS: Lt });
var U = /[a-z]/;
var pe = new RegExp("\\p{L}", "u");
var mt = new RegExp("\\p{Emoji}", "u");
var K = /\d/;
var ft = /\s/;
var vo = "\r";
var bt = `
`;
var Hn = "️";
var xn = "‍";
var vt = "￼";
var He = null;
var xe = null;
function Ln(e = []) {
  let t = {};
  R.groups = t;
  let o = new R();
  He == null && (He = yo(yn)), xe == null && (xe = yo(Tn)), p(o, "'", Ke), p(o, "{", me), p(o, "}", fe), p(o, "[", we), p(o, "]", Oe), p(o, "(", Ae), p(o, ")", Fe), p(o, "<", Se), p(o, ">", Re), p(o, "（", Ne), p(o, "）", Ie), p(o, "「", De), p(o, "」", Be), p(o, "『", ze), p(o, "』", $e), p(o, "＜", _e), p(o, "＞", je), p(o, "&", Ue), p(o, "*", We), p(o, "@", Y), p(o, "`", Ve), p(o, "^", qe), p(o, ":", Q), p(o, ",", Ot), p(o, "$", Ye), p(o, ".", z), p(o, "=", Qe), p(o, "!", At), p(o, "-", D), p(o, "%", be), p(o, "|", Je), p(o, "+", Xe), p(o, "#", Ze), p(o, "?", ve), p(o, '"', Ft), p(o, "/", $), p(o, ";", St), p(o, "~", ye), p(o, "_", et), p(o, "\\", Ge), p(o, "・", xo);
  let r = L(o, K, Mt, { [Tt]: true });
  L(r, K, r);
  let n = L(r, U, Co, { [ge]: true }), i = L(r, pe, Ho, { [he]: true }), s = L(o, U, W, { [Et]: true });
  L(s, K, n), L(s, U, s), L(n, K, n), L(n, U, n);
  let a = L(o, pe, Ct, { [Pt]: true });
  L(a, U), L(a, K, i), L(a, pe, a), L(i, K, i), L(i, U), L(i, pe, i);
  let l = p(o, bt, wt, { [gt]: true }), d = p(o, vo, Lt, { [gt]: true }), c = L(o, ft, Lt, { [gt]: true });
  p(o, vt, c), p(d, bt, l), p(d, vt, c), L(d, ft, c), p(c, vo), p(c, bt), L(c, ft, c), p(c, vt, c);
  let u = L(o, mt, Lo, { [ko]: true });
  p(u, "#"), L(u, mt, u), p(u, Hn, u);
  let h2 = p(u, xn);
  p(h2, "#"), L(h2, mt, u);
  let m = [[U, s], [K, n]], f = [[U, null], [pe, a], [K, i]];
  for (let v = 0; v < He.length; v++) q(o, He[v], Ht, W, m);
  for (let v = 0; v < xe.length; v++) q(o, xe[v], xt, Ct, f);
  ee(Ht, { tld: true, ascii: true }, t), ee(xt, { utld: true, alpha: true }, t), q(o, "file", Me, W, m), q(o, "mailto", Me, W, m), q(o, "http", ae, W, m), q(o, "https", ae, W, m), q(o, "ftp", ae, W, m), q(o, "ftps", ae, W, m), ee(Me, { scheme: true, ascii: true }, t), ee(ae, { slashscheme: true, ascii: true }, t), e = e.sort((v, T) => v[0] > T[0] ? 1 : -1);
  for (let v = 0; v < e.length; v++) {
    let T = e[v][0], b = e[v][1] ? { [En]: true } : { [Pn]: true };
    T.indexOf("-") >= 0 ? b[kt] = true : U.test(T) ? K.test(T) ? b[ge] = true : b[Et] = true : b[Tt] = true, bo(o, T, T, b);
  }
  return bo(o, "localhost", Te, { ascii: true }), o.jd = new R(tt), { start: o, tokens: Object.assign({ groups: t }, Mo) };
}
function wo(e, t) {
  let o = Mn(t.replace(/[A-Z]/g, (a) => a.toLowerCase())), r = o.length, n = [], i = 0, s = 0;
  for (; s < r; ) {
    let a = e, l = null, d = 0, c = null, u = -1, h2 = -1;
    for (; s < r && (l = a.go(o[s])); ) a = l, a.accepts() ? (u = 0, h2 = 0, c = a) : u >= 0 && (u += o[s].length, h2++), d += o[s].length, i += o[s].length, s++;
    i -= u, s -= h2, d -= u, n.push({ t: c.t, v: t.slice(i - d, i), s: i - d, e: i });
  }
  return n;
}
function Mn(e) {
  let t = [], o = e.length, r = 0;
  for (; r < o; ) {
    let n = e.charCodeAt(r), i, s = n < 55296 || n > 56319 || r + 1 === o || (i = e.charCodeAt(r + 1)) < 56320 || i > 57343 ? e[r] : e.slice(r, r + 2);
    t.push(s), r += s.length;
  }
  return t;
}
function q(e, t, o, r, n) {
  let i, s = t.length;
  for (let a = 0; a < s - 1; a++) {
    let l = t[a];
    e.j[l] ? i = e.j[l] : (i = new R(r), i.jr = n.slice(), e.j[l] = i), e = i;
  }
  return i = new R(o), i.jr = n.slice(), e.j[t[s - 1]] = i, i;
}
function yo(e) {
  let t = [], o = [], r = 0, n = "0123456789";
  for (; r < e.length; ) {
    let i = 0;
    for (; n.indexOf(e[r + i]) >= 0; ) i++;
    if (i > 0) {
      t.push(o.join(""));
      for (let s = parseInt(e.substring(r, r + i), 10); s > 0; s--) o.pop();
      r += i;
    } else o.push(e[r]), r++;
  }
  return t;
}
var Ee = { defaultProtocol: "http", events: null, format: To, formatHref: To, nl2br: false, tagName: "a", target: null, rel: null, validate: true, truncate: 1 / 0, className: null, attributes: null, ignoreTags: [], render: null };
function Rt(e, t = null) {
  let o = Object.assign({}, Ee);
  e && (o = Object.assign(o, e instanceof Rt ? e.o : e));
  let r = o.ignoreTags, n = [];
  for (let i = 0; i < r.length; i++) n.push(r[i].toUpperCase());
  this.o = o, t && (this.defaultRender = t), this.ignoreTags = n;
}
Rt.prototype = { o: Ee, ignoreTags: [], defaultRender(e) {
  return e;
}, check(e) {
  return this.get("validate", e.toString(), e);
}, get(e, t, o) {
  let r = t != null, n = this.o[e];
  return n && (typeof n == "object" ? (n = o.t in n ? n[o.t] : Ee[e], typeof n == "function" && r && (n = n(t, o))) : typeof n == "function" && r && (n = n(t, o.t, o)), n);
}, getObj(e, t, o) {
  let r = this.o[e];
  return typeof r == "function" && t != null && (r = r(t, o.t, o)), r;
}, render(e) {
  let t = e.render(this);
  return (this.get("render", null, e) || this.defaultRender)(t, e.t, e);
} };
function To(e) {
  return e;
}
function Oo(e, t) {
  this.t = "token", this.v = e, this.tk = t;
}
Oo.prototype = { isLink: false, toString() {
  return this.v;
}, toHref(e) {
  return this.toString();
}, toFormattedString(e) {
  let t = this.toString(), o = e.get("truncate", t, this), r = e.get("format", t, this);
  return o && r.length > o ? r.substring(0, o) + "…" : r;
}, toFormattedHref(e) {
  return e.get("formatHref", this.toHref(e.get("defaultProtocol")), this);
}, startIndex() {
  return this.tk[0].s;
}, endIndex() {
  return this.tk[this.tk.length - 1].e;
}, toObject(e = Ee.defaultProtocol) {
  return { type: this.t, value: this.toString(), isLink: this.isLink, href: this.toHref(e), start: this.startIndex(), end: this.endIndex() };
}, toFormattedObject(e) {
  return { type: this.t, value: this.toFormattedString(e), isLink: this.isLink, href: this.toFormattedHref(e), start: this.startIndex(), end: this.endIndex() };
}, validate(e) {
  return e.get("validate", this.toString(), this);
}, render(e) {
  let t = this, o = this.toHref(e.get("defaultProtocol")), r = e.get("formatHref", o, this), n = e.get("tagName", o, t), i = this.toFormattedString(e), s = {}, a = e.get("className", o, t), l = e.get("target", o, t), d = e.get("rel", o, t), c = e.getObj("attributes", o, t), u = e.getObj("events", o, t);
  return s.href = r, a && (s.class = a), l && (s.target = l), d && (s.rel = d), c && Object.assign(s, c), { tagName: n, attributes: s, content: i, eventListeners: u };
} };
function ot(e, t) {
  class o extends Oo {
    constructor(n, i) {
      super(n, i), this.t = e;
    }
  }
  for (let r in t) o.prototype[r] = t[r];
  return o.t = e, o;
}
var Eo = ot("email", { isLink: true, toHref() {
  return "mailto:" + this.toString();
} });
var Po = ot("text");
var wn = ot("nl");
var Le = ot("url", { isLink: true, toHref(e = Ee.defaultProtocol) {
  return this.hasProtocol() ? this.v : `${e}://${this.v}`;
}, hasProtocol() {
  let e = this.tk;
  return e.length >= 2 && e[0].t !== Te && e[1].t === Q;
} });
var I = (e) => new R(e);
function On({ groups: e }) {
  let t = e.domain.concat([Ue, We, Y, Ge, Ve, qe, Ye, Qe, D, Mt, be, Je, Xe, Ze, $, tt, ye, et]), o = [Ke, Q, Ot, z, At, be, ve, Ft, St, Se, Re, me, fe, Oe, we, Ae, Fe, Ne, Ie, De, Be, ze, $e, _e, je], r = [Ue, Ke, We, Ge, Ve, qe, Ye, Qe, D, me, fe, be, Je, Xe, Ze, ve, $, tt, ye, et], n = I(), i = p(n, ye);
  y(i, r, i), y(i, e.domain, i);
  let s = I(), a = I(), l = I();
  y(n, e.domain, s), y(n, e.scheme, a), y(n, e.slashscheme, l), y(s, r, i), y(s, e.domain, s);
  let d = p(s, Y);
  p(i, Y, d), p(a, Y, d), p(l, Y, d);
  let c = p(i, z);
  y(c, r, i), y(c, e.domain, i);
  let u = I();
  y(d, e.domain, u), y(u, e.domain, u);
  let h2 = p(u, z);
  y(h2, e.domain, u);
  let m = I(Eo);
  y(h2, e.tld, m), y(h2, e.utld, m), p(d, Te, m);
  let f = p(u, D);
  p(f, D, f), y(f, e.domain, u), y(m, e.domain, u), p(m, z, h2), p(m, D, f);
  let v = p(m, Q);
  y(v, e.numeric, Eo);
  let T = p(s, D), g = p(s, z);
  p(T, D, T), y(T, e.domain, s), y(g, r, i), y(g, e.domain, s);
  let b = I(Le);
  y(g, e.tld, b), y(g, e.utld, b), y(b, e.domain, s), y(b, r, i), p(b, z, g), p(b, D, T), p(b, Y, d);
  let x = p(b, Q), k = I(Le);
  y(x, e.numeric, k);
  let P = I(Le), M = I();
  y(P, t, P), y(P, o, M), y(M, t, P), y(M, o, M), p(b, $, P), p(k, $, P);
  let F = p(a, Q), G = p(l, Q), ie = p(G, $), V = p(ie, $);
  y(a, e.domain, s), p(a, z, g), p(a, D, T), y(l, e.domain, s), p(l, z, g), p(l, D, T), y(F, e.domain, P), p(F, $, P), p(F, ve, P), y(V, e.domain, P), y(V, t, P), p(V, $, P);
  let ct = [[me, fe], [we, Oe], [Ae, Fe], [Se, Re], [Ne, Ie], [De, Be], [ze, $e], [_e, je]];
  for (let X = 0; X < ct.length; X++) {
    let [O, A] = ct[X], Z = p(P, O);
    p(M, O, Z), p(Z, A, P);
    let S = I(Le);
    y(Z, t, S);
    let w = I();
    y(Z, o), y(S, t, S), y(S, o, w), y(w, t, S), y(w, o, w), p(S, A, P), p(w, A, P);
  }
  return p(n, Te, b), p(n, wt, wn), { start: n, tokens: Mo };
}
function An(e, t, o) {
  let r = o.length, n = 0, i = [], s = [];
  for (; n < r; ) {
    let a = e, l = null, d = null, c = 0, u = null, h2 = -1;
    for (; n < r && !(l = a.go(o[n].t)); ) s.push(o[n++]);
    for (; n < r && (d = l || a.go(o[n].t)); ) l = null, a = d, a.accepts() ? (h2 = 0, u = a) : h2 >= 0 && h2++, n++, c++;
    if (h2 < 0) n -= c, n < r && (s.push(o[n]), n++);
    else {
      s.length > 0 && (i.push(yt(Po, t, s)), s = []), n -= h2, c -= h2;
      let m = u.t, f = o.slice(n - c, n);
      i.push(yt(m, t, f));
    }
  }
  return s.length > 0 && i.push(yt(Po, t, s)), i;
}
function yt(e, t, o) {
  let r = o[0].s, n = o[o.length - 1].e, i = t.slice(r, n);
  return new e(i, o);
}
var Fn = typeof console != "undefined" && console && console.warn || (() => {
});
var Sn = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.";
var C = { scanner: null, parser: null, tokenQueue: [], pluginQueue: [], customSchemes: [], initialized: false };
function Ao() {
  return R.groups = {}, C.scanner = null, C.parser = null, C.tokenQueue = [], C.pluginQueue = [], C.customSchemes = [], C.initialized = false, C;
}
function Nt(e, t = false) {
  if (C.initialized && Fn(`linkifyjs: already initialized - will not register custom scheme "${e}" ${Sn}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(e)) throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  C.customSchemes.push([e, t]);
}
function Rn() {
  C.scanner = Ln(C.customSchemes);
  for (let e = 0; e < C.tokenQueue.length; e++) C.tokenQueue[e][1]({ scanner: C.scanner });
  C.parser = On(C.scanner.tokens);
  for (let e = 0; e < C.pluginQueue.length; e++) C.pluginQueue[e][1]({ scanner: C.scanner, parser: C.parser });
  return C.initialized = true, C;
}
function rt(e) {
  return C.initialized || Rn(), An(C.parser.start, e, wo(C.scanner.start, e));
}
rt.scan = wo;
function nt(e, t = null, o = null) {
  if (t && typeof t == "object") {
    if (o) throw Error(`linkifyjs: Invalid link type ${t}; must be a string`);
    o = t, t = null;
  }
  let r = new Rt(o), n = rt(e), i = [];
  for (let s = 0; s < n.length; s++) {
    let a = n[s];
    a.isLink && (!t || a.t === t) && r.check(a) && i.push(a.toFormattedObject(r));
  }
  return i;
}
var It = "[\0-   ᠎ -\u2029 　]";
var Un = new RegExp(It);
var Kn = new RegExp(`${It}$`);
var Wn = new RegExp(It, "g");
function Gn(e) {
  return e.length === 1 ? e[0].isLink : e.length === 3 && e[1].isLink ? ["()", "[]"].includes(e[0].value + e[2].value) : false;
}
function Vn(e) {
  return new Plugin({ key: new PluginKey("autolink"), appendTransaction: (t, o, r) => {
    let n = t.some((d) => d.docChanged) && !o.doc.eq(r.doc), i = t.some((d) => d.getMeta("preventAutolink"));
    if (!n || i) return;
    let { tr: s } = r, a = combineTransactionSteps(o.doc, [...t]);
    if (getChangedRanges(a).forEach(({ newRange: d }) => {
      let c = findChildrenInRange(r.doc, d, (m) => m.isTextblock), u, h2;
      if (c.length > 1) u = c[0], h2 = r.doc.textBetween(u.pos, u.pos + u.node.nodeSize, void 0, " ");
      else if (c.length) {
        let m = r.doc.textBetween(d.from, d.to, " ", " ");
        if (!Kn.test(m)) return;
        u = c[0], h2 = r.doc.textBetween(u.pos, d.to, void 0, " ");
      }
      if (u && h2) {
        let m = h2.split(Un).filter(Boolean);
        if (m.length <= 0) return false;
        let f = m[m.length - 1], v = u.pos + h2.lastIndexOf(f);
        if (!f) return false;
        let T = rt(f).map((g) => g.toObject(e.defaultProtocol));
        if (!Gn(T)) return false;
        T.filter((g) => g.isLink).map((g) => ({ ...g, from: v + g.start + 1, to: v + g.end + 1 })).filter((g) => r.schema.marks.code ? !r.doc.rangeHasMark(g.from, g.to, r.schema.marks.code) : true).filter((g) => e.validate(g.value)).filter((g) => e.shouldAutoLink(g.value)).forEach((g) => {
          getMarksBetween(g.from, g.to, r.doc).some((b) => b.mark.type === e.type) || s.addMark(g.from, g.to, e.type.create({ href: g.href }));
        });
      }
    }), !!s.steps.length) return s;
  } });
}
function Jn(e) {
  return new Plugin({ key: new PluginKey("handleClickLink"), props: { handleClick: (t, o, r) => {
    var n, i;
    if (r.button !== 0 || !t.editable) return false;
    let s = null;
    if (r.target instanceof HTMLAnchorElement) s = r.target;
    else {
      let c = r.target, u = [];
      for (; c.nodeName !== "DIV"; ) u.push(c), c = c.parentNode;
      s = u.find((h2) => h2.nodeName === "A");
    }
    if (!s) return false;
    let a = getAttributes(t.state, e.type.name), l = (n = s == null ? void 0 : s.href) != null ? n : a.href, d = (i = s == null ? void 0 : s.target) != null ? i : a.target;
    return e.enableClickSelection && e.editor.commands.extendMarkRange(e.type.name), s && l ? (window.open(l, d), true) : false;
  } } });
}
function ei(e) {
  return new Plugin({ key: new PluginKey("handlePasteLink"), props: { handlePaste: (t, o, r) => {
    let { state: n } = t, { selection: i } = n, { empty: s } = i;
    if (s) return false;
    let a = "";
    r.content.forEach((d) => {
      a += d.textContent;
    });
    let l = nt(a, { defaultProtocol: e.defaultProtocol }).find((d) => d.isLink && d.value === a);
    return !a || !l ? false : e.editor.commands.setMark(e.type, { href: l.href });
  } } });
}
function te(e, t) {
  let o = ["http", "https", "ftp", "ftps", "mailto", "tel", "callto", "sms", "cid", "xmpp"];
  return t && t.forEach((r) => {
    let n = typeof r == "string" ? r : r.scheme;
    n && o.push(n);
  }), !e || e.replace(Wn, "").match(new RegExp(`^(?:(?:${o.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`, "i"));
}
var So = Mark.create({ name: "link", priority: 1e3, keepOnSplit: false, exitable: true, onCreate() {
  this.options.validate && !this.options.shouldAutoLink && (this.options.shouldAutoLink = this.options.validate, console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.")), this.options.protocols.forEach((e) => {
    if (typeof e == "string") {
      Nt(e);
      return;
    }
    Nt(e.scheme, e.optionalSlashes);
  });
}, onDestroy() {
  Ao();
}, inclusive() {
  return this.options.autolink;
}, addOptions() {
  return { openOnClick: true, enableClickSelection: false, linkOnPaste: true, autolink: true, protocols: [], defaultProtocol: "http", HTMLAttributes: { target: "_blank", rel: "noopener noreferrer nofollow", class: null }, isAllowedUri: (e, t) => !!te(e, t.protocols), validate: (e) => !!e, shouldAutoLink: (e) => !!e };
}, addAttributes() {
  return { href: { default: null, parseHTML(e) {
    return e.getAttribute("href");
  } }, target: { default: this.options.HTMLAttributes.target }, rel: { default: this.options.HTMLAttributes.rel }, class: { default: this.options.HTMLAttributes.class } };
}, parseHTML() {
  return [{ tag: "a[href]", getAttrs: (e) => {
    let t = e.getAttribute("href");
    return !t || !this.options.isAllowedUri(t, { defaultValidate: (o) => !!te(o, this.options.protocols), protocols: this.options.protocols, defaultProtocol: this.options.defaultProtocol }) ? false : null;
  } }];
}, renderHTML({ HTMLAttributes: e }) {
  return this.options.isAllowedUri(e.href, { defaultValidate: (t) => !!te(t, this.options.protocols), protocols: this.options.protocols, defaultProtocol: this.options.defaultProtocol }) ? ["a", mergeAttributes(this.options.HTMLAttributes, e), 0] : ["a", mergeAttributes(this.options.HTMLAttributes, { ...e, href: "" }), 0];
}, addCommands() {
  return { setLink: (e) => ({ chain: t }) => {
    let { href: o } = e;
    return this.options.isAllowedUri(o, { defaultValidate: (r) => !!te(r, this.options.protocols), protocols: this.options.protocols, defaultProtocol: this.options.defaultProtocol }) ? t().setMark(this.name, e).setMeta("preventAutolink", true).run() : false;
  }, toggleLink: (e) => ({ chain: t }) => {
    let { href: o } = e || {};
    return o && !this.options.isAllowedUri(o, { defaultValidate: (r) => !!te(r, this.options.protocols), protocols: this.options.protocols, defaultProtocol: this.options.defaultProtocol }) ? false : t().toggleMark(this.name, e, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
  }, unsetLink: () => ({ chain: e }) => e().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run() };
}, addPasteRules() {
  return [markPasteRule({ find: (e) => {
    let t = [];
    if (e) {
      let { protocols: o, defaultProtocol: r } = this.options, n = nt(e).filter((i) => i.isLink && this.options.isAllowedUri(i.value, { defaultValidate: (s) => !!te(s, o), protocols: o, defaultProtocol: r }));
      n.length && n.forEach((i) => t.push({ text: i.value, data: { href: i.href }, index: i.start }));
    }
    return t;
  }, type: this.type, getAttributes: (e) => {
    var t;
    return { href: (t = e.data) == null ? void 0 : t.href };
  } })];
}, addProseMirrorPlugins() {
  let e = [], { protocols: t, defaultProtocol: o } = this.options;
  return this.options.autolink && e.push(Vn({ type: this.type, defaultProtocol: this.options.defaultProtocol, validate: (r) => this.options.isAllowedUri(r, { defaultValidate: (n) => !!te(n, t), protocols: t, defaultProtocol: o }), shouldAutoLink: this.options.shouldAutoLink })), this.options.openOnClick === true && e.push(Jn({ type: this.type, editor: this.editor, enableClickSelection: this.options.enableClickSelection })), this.options.linkOnPaste && e.push(ei({ editor: this.editor, defaultProtocol: this.options.defaultProtocol, type: this.type })), e;
} });
var ti = Object.defineProperty;
var oi = (e, t) => {
  for (var o in t) ti(e, o, { get: t[o], enumerable: true });
};
var ii = "listItem";
var No = "textStyle";
var Io = /^\s*([-+*])\s$/;
var zt = Node3.create({ name: "bulletList", addOptions() {
  return { itemTypeName: "listItem", HTMLAttributes: {}, keepMarks: false, keepAttributes: false };
}, group: "block list", content() {
  return `${this.options.itemTypeName}+`;
}, parseHTML() {
  return [{ tag: "ul" }];
}, renderHTML({ HTMLAttributes: e }) {
  return ["ul", mergeAttributes(this.options.HTMLAttributes, e), 0];
}, addCommands() {
  return { toggleBulletList: () => ({ commands: e, chain: t }) => this.options.keepAttributes ? t().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ii, this.editor.getAttributes(No)).run() : e.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks) };
}, addKeyboardShortcuts() {
  return { "Mod-Shift-8": () => this.editor.commands.toggleBulletList() };
}, addInputRules() {
  let e = wrappingInputRule({ find: Io, type: this.type });
  return (this.options.keepMarks || this.options.keepAttributes) && (e = wrappingInputRule({ find: Io, type: this.type, keepMarks: this.options.keepMarks, keepAttributes: this.options.keepAttributes, getAttributes: () => this.editor.getAttributes(No), editor: this.editor })), [e];
} });
var $t = Node3.create({ name: "listItem", addOptions() {
  return { HTMLAttributes: {}, bulletListTypeName: "bulletList", orderedListTypeName: "orderedList" };
}, content: "paragraph block*", defining: true, parseHTML() {
  return [{ tag: "li" }];
}, renderHTML({ HTMLAttributes: e }) {
  return ["li", mergeAttributes(this.options.HTMLAttributes, e), 0];
}, addKeyboardShortcuts() {
  return { Enter: () => this.editor.commands.splitListItem(this.name), Tab: () => this.editor.commands.sinkListItem(this.name), "Shift-Tab": () => this.editor.commands.liftListItem(this.name) };
} });
var di = {};
oi(di, { findListItemPos: () => Pe, getNextListDepth: () => _t, handleBackspace: () => Dt, handleDelete: () => Bt, hasListBefore: () => jo, hasListItemAfter: () => fi, hasListItemBefore: () => Uo, listItemHasSubList: () => Ko, nextListIsDeeper: () => Wo, nextListIsHigher: () => Go });
var Pe = (e, t) => {
  let { $from: o } = t.selection, r = getNodeType(e, t.schema), n = null, i = o.depth, s = o.pos, a = null;
  for (; i > 0 && a === null; ) n = o.node(i), n.type === r ? a = i : (i -= 1, s -= 1);
  return a === null ? null : { $pos: t.doc.resolve(s), depth: a };
};
var _t = (e, t) => {
  let o = Pe(e, t);
  if (!o) return false;
  let [, r] = getNodeAtPosition(t, e, o.$pos.pos + 4);
  return r;
};
var jo = (e, t, o) => {
  let { $anchor: r } = e.selection, n = Math.max(0, r.pos - 2), i = e.doc.resolve(n).node();
  return !(!i || !o.includes(i.type.name));
};
var Uo = (e, t) => {
  var o;
  let { $anchor: r } = t.selection, n = t.doc.resolve(r.pos - 2);
  return !(n.index() === 0 || ((o = n.nodeBefore) == null ? void 0 : o.type.name) !== e);
};
var Ko = (e, t, o) => {
  if (!o) return false;
  let r = getNodeType(e, t.schema), n = false;
  return o.descendants((i) => {
    i.type === r && (n = true);
  }), n;
};
var Dt = (e, t, o) => {
  if (e.commands.undoInputRule()) return true;
  if (e.state.selection.from !== e.state.selection.to) return false;
  if (!isNodeActive(e.state, t) && jo(e.state, t, o)) {
    let { $anchor: a } = e.state.selection, l = e.state.doc.resolve(a.before() - 1), d = [];
    l.node().descendants((h2, m) => {
      h2.type.name === t && d.push({ node: h2, pos: m });
    });
    let c = d.at(-1);
    if (!c) return false;
    let u = e.state.doc.resolve(l.start() + c.pos + 1);
    return e.chain().cut({ from: a.start() - 1, to: a.end() + 1 }, u.end()).joinForward().run();
  }
  if (!isNodeActive(e.state, t) || !isAtStartOfNode(e.state)) return false;
  let r = Pe(t, e.state);
  if (!r) return false;
  let i = e.state.doc.resolve(r.$pos.pos - 2).node(r.depth), s = Ko(t, e.state, i);
  return Uo(t, e.state) && !s ? e.commands.joinItemBackward() : e.chain().liftListItem(t).run();
};
var Wo = (e, t) => {
  let o = _t(e, t), r = Pe(e, t);
  return !r || !o ? false : o > r.depth;
};
var Go = (e, t) => {
  let o = _t(e, t), r = Pe(e, t);
  return !r || !o ? false : o < r.depth;
};
var Bt = (e, t) => {
  if (!isNodeActive(e.state, t) || !isAtEndOfNode(e.state, t)) return false;
  let { selection: o } = e.state, { $from: r, $to: n } = o;
  return !o.empty && r.sameParent(n) ? false : Wo(t, e.state) ? e.chain().focus(e.state.selection.from + 4).lift(t).joinBackward().run() : Go(t, e.state) ? e.chain().joinForward().joinBackward().run() : e.commands.joinItemForward();
};
var fi = (e, t) => {
  var o;
  let { $anchor: r } = t.selection, n = t.doc.resolve(r.pos - r.parentOffset - 2);
  return !(n.index() === n.parent.childCount - 1 || ((o = n.nodeAfter) == null ? void 0 : o.type.name) !== e);
};
var jt = Extension.create({ name: "listKeymap", addOptions() {
  return { listTypes: [{ itemName: "listItem", wrapperNames: ["bulletList", "orderedList"] }, { itemName: "taskItem", wrapperNames: ["taskList"] }] };
}, addKeyboardShortcuts() {
  return { Delete: ({ editor: e }) => {
    let t = false;
    return this.options.listTypes.forEach(({ itemName: o }) => {
      e.state.schema.nodes[o] !== void 0 && Bt(e, o) && (t = true);
    }), t;
  }, "Mod-Delete": ({ editor: e }) => {
    let t = false;
    return this.options.listTypes.forEach(({ itemName: o }) => {
      e.state.schema.nodes[o] !== void 0 && Bt(e, o) && (t = true);
    }), t;
  }, Backspace: ({ editor: e }) => {
    let t = false;
    return this.options.listTypes.forEach(({ itemName: o, wrapperNames: r }) => {
      e.state.schema.nodes[o] !== void 0 && Dt(e, o, r) && (t = true);
    }), t;
  }, "Mod-Backspace": ({ editor: e }) => {
    let t = false;
    return this.options.listTypes.forEach(({ itemName: o, wrapperNames: r }) => {
      e.state.schema.nodes[o] !== void 0 && Dt(e, o, r) && (t = true);
    }), t;
  } };
} });
var yi = "listItem";
var $o = "textStyle";
var _o = /^(\d+)\.\s$/;
var Ut = Node3.create({ name: "orderedList", addOptions() {
  return { itemTypeName: "listItem", HTMLAttributes: {}, keepMarks: false, keepAttributes: false };
}, group: "block list", content() {
  return `${this.options.itemTypeName}+`;
}, addAttributes() {
  return { start: { default: 1, parseHTML: (e) => e.hasAttribute("start") ? parseInt(e.getAttribute("start") || "", 10) : 1 }, type: { default: null, parseHTML: (e) => e.getAttribute("type") } };
}, parseHTML() {
  return [{ tag: "ol" }];
}, renderHTML({ HTMLAttributes: e }) {
  let { start: t, ...o } = e;
  return t === 1 ? ["ol", mergeAttributes(this.options.HTMLAttributes, o), 0] : ["ol", mergeAttributes(this.options.HTMLAttributes, e), 0];
}, addCommands() {
  return { toggleOrderedList: () => ({ commands: e, chain: t }) => this.options.keepAttributes ? t().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(yi, this.editor.getAttributes($o)).run() : e.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks) };
}, addKeyboardShortcuts() {
  return { "Mod-Shift-7": () => this.editor.commands.toggleOrderedList() };
}, addInputRules() {
  let e = wrappingInputRule({ find: _o, type: this.type, getAttributes: (t) => ({ start: +t[1] }), joinPredicate: (t, o) => o.childCount + o.attrs.start === +t[1] });
  return (this.options.keepMarks || this.options.keepAttributes) && (e = wrappingInputRule({ find: _o, type: this.type, keepMarks: this.options.keepMarks, keepAttributes: this.options.keepAttributes, getAttributes: (t) => ({ start: +t[1], ...this.editor.getAttributes($o) }), joinPredicate: (t, o) => o.childCount + o.attrs.start === +t[1], editor: this.editor })), [e];
} });
var ki = /^\s*(\[([( |x])?\])\s$/;
var Ci = Node3.create({ name: "taskItem", addOptions() {
  return { nested: false, HTMLAttributes: {}, taskListTypeName: "taskList", a11y: void 0 };
}, content() {
  return this.options.nested ? "paragraph block*" : "paragraph+";
}, defining: true, addAttributes() {
  return { checked: { default: false, keepOnSplit: false, parseHTML: (e) => {
    let t = e.getAttribute("data-checked");
    return t === "" || t === "true";
  }, renderHTML: (e) => ({ "data-checked": e.checked }) } };
}, parseHTML() {
  return [{ tag: `li[data-type="${this.name}"]`, priority: 51 }];
}, renderHTML({ node: e, HTMLAttributes: t }) {
  return ["li", mergeAttributes(this.options.HTMLAttributes, t, { "data-type": this.name }), ["label", ["input", { type: "checkbox", checked: e.attrs.checked ? "checked" : null }], ["span"]], ["div", 0]];
}, addKeyboardShortcuts() {
  let e = { Enter: () => this.editor.commands.splitListItem(this.name), "Shift-Tab": () => this.editor.commands.liftListItem(this.name) };
  return this.options.nested ? { ...e, Tab: () => this.editor.commands.sinkListItem(this.name) } : e;
}, addNodeView() {
  return ({ node: e, HTMLAttributes: t, getPos: o, editor: r }) => {
    let n = document.createElement("li"), i = document.createElement("label"), s = document.createElement("span"), a = document.createElement("input"), l = document.createElement("div"), d = (c) => {
      var u, h2;
      a.ariaLabel = ((h2 = (u = this.options.a11y) == null ? void 0 : u.checkboxLabel) == null ? void 0 : h2.call(u, c, a.checked)) || `Task item checkbox for ${c.textContent || "empty task item"}`;
    };
    return d(e), i.contentEditable = "false", a.type = "checkbox", a.addEventListener("mousedown", (c) => c.preventDefault()), a.addEventListener("change", (c) => {
      if (!r.isEditable && !this.options.onReadOnlyChecked) {
        a.checked = !a.checked;
        return;
      }
      let { checked: u } = c.target;
      r.isEditable && typeof o == "function" && r.chain().focus(void 0, { scrollIntoView: false }).command(({ tr: h2 }) => {
        let m = o();
        if (typeof m != "number") return false;
        let f = h2.doc.nodeAt(m);
        return h2.setNodeMarkup(m, void 0, { ...f == null ? void 0 : f.attrs, checked: u }), true;
      }).run(), !r.isEditable && this.options.onReadOnlyChecked && (this.options.onReadOnlyChecked(e, u) || (a.checked = !a.checked));
    }), Object.entries(this.options.HTMLAttributes).forEach(([c, u]) => {
      n.setAttribute(c, u);
    }), n.dataset.checked = e.attrs.checked, a.checked = e.attrs.checked, i.append(a, s), n.append(i, l), Object.entries(t).forEach(([c, u]) => {
      n.setAttribute(c, u);
    }), { dom: n, contentDOM: l, update: (c) => c.type !== this.type ? false : (n.dataset.checked = c.attrs.checked, a.checked = c.attrs.checked, d(c), true) };
  };
}, addInputRules() {
  return [wrappingInputRule({ find: ki, type: this.type, getAttributes: (e) => ({ checked: e[e.length - 1] === "x" }) })];
} });
var Li = Node3.create({ name: "taskList", addOptions() {
  return { itemTypeName: "taskItem", HTMLAttributes: {} };
}, group: "block list", content() {
  return `${this.options.itemTypeName}+`;
}, parseHTML() {
  return [{ tag: `ul[data-type="${this.name}"]`, priority: 51 }];
}, renderHTML({ HTMLAttributes: e }) {
  return ["ul", mergeAttributes(this.options.HTMLAttributes, e, { "data-type": this.name }), 0];
}, addCommands() {
  return { toggleTaskList: () => ({ commands: e }) => e.toggleList(this.name, this.options.itemTypeName) };
}, addKeyboardShortcuts() {
  return { "Mod-Shift-9": () => this.editor.commands.toggleTaskList() };
} });
var qa = Extension.create({ name: "listKit", addExtensions() {
  let e = [];
  return this.options.bulletList !== false && e.push(zt.configure(this.options.bulletList)), this.options.listItem !== false && e.push($t.configure(this.options.listItem)), this.options.listKeymap !== false && e.push(jt.configure(this.options.listKeymap)), this.options.orderedList !== false && e.push(Ut.configure(this.options.orderedList)), this.options.taskItem !== false && e.push(Ci.configure(this.options.taskItem)), this.options.taskList !== false && e.push(Li.configure(this.options.taskList)), e;
} });
var Vo = Node3.create({ name: "paragraph", priority: 1e3, addOptions() {
  return { HTMLAttributes: {} };
}, group: "block", content: "inline*", parseHTML() {
  return [{ tag: "p" }];
}, renderHTML({ HTMLAttributes: e }) {
  return ["p", mergeAttributes(this.options.HTMLAttributes, e), 0];
}, addCommands() {
  return { setParagraph: () => ({ commands: e }) => e.setNode(this.name) };
}, addKeyboardShortcuts() {
  return { "Mod-Alt-0": () => this.editor.commands.setParagraph() };
} });
var Ri = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/;
var Ni = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g;
var qo = Mark.create({ name: "strike", addOptions() {
  return { HTMLAttributes: {} };
}, parseHTML() {
  return [{ tag: "s" }, { tag: "del" }, { tag: "strike" }, { style: "text-decoration", consuming: false, getAttrs: (e) => e.includes("line-through") ? {} : false }];
}, renderHTML({ HTMLAttributes: e }) {
  return ["s", mergeAttributes(this.options.HTMLAttributes, e), 0];
}, addCommands() {
  return { setStrike: () => ({ commands: e }) => e.setMark(this.name), toggleStrike: () => ({ commands: e }) => e.toggleMark(this.name), unsetStrike: () => ({ commands: e }) => e.unsetMark(this.name) };
}, addKeyboardShortcuts() {
  return { "Mod-Shift-s": () => this.editor.commands.toggleStrike() };
}, addInputRules() {
  return [markInputRule({ find: Ri, type: this.type })];
}, addPasteRules() {
  return [markPasteRule({ find: Ni, type: this.type })];
} });
var Yo = Node3.create({ name: "text", group: "inline" });
var Qo = Mark.create({ name: "underline", addOptions() {
  return { HTMLAttributes: {} };
}, parseHTML() {
  return [{ tag: "u" }, { style: "text-decoration", consuming: false, getAttrs: (e) => e.includes("underline") ? {} : false }];
}, renderHTML({ HTMLAttributes: e }) {
  return ["u", mergeAttributes(this.options.HTMLAttributes, e), 0];
}, addCommands() {
  return { setUnderline: () => ({ commands: e }) => e.setMark(this.name), toggleUnderline: () => ({ commands: e }) => e.toggleMark(this.name), unsetUnderline: () => ({ commands: e }) => e.unsetMark(this.name) };
}, addKeyboardShortcuts() {
  return { "Mod-u": () => this.editor.commands.toggleUnderline(), "Mod-U": () => this.editor.commands.toggleUnderline() };
} });
var sl = Extension.create({ name: "characterCount", addOptions() {
  return { limit: null, mode: "textSize", textCounter: (e) => e.length, wordCounter: (e) => e.split(" ").filter((t) => t !== "").length };
}, addStorage() {
  return { characters: () => 0, words: () => 0 };
}, onBeforeCreate() {
  this.storage.characters = (e) => {
    let t = (e == null ? void 0 : e.node) || this.editor.state.doc;
    if (((e == null ? void 0 : e.mode) || this.options.mode) === "textSize") {
      let r = t.textBetween(0, t.content.size, void 0, " ");
      return this.options.textCounter(r);
    }
    return t.nodeSize;
  }, this.storage.words = (e) => {
    let t = (e == null ? void 0 : e.node) || this.editor.state.doc, o = t.textBetween(0, t.content.size, " ", " ");
    return this.options.wordCounter(o);
  };
}, addProseMirrorPlugins() {
  let e = false;
  return [new Plugin({ key: new PluginKey("characterCount"), appendTransaction: (t, o, r) => {
    if (e) return;
    let n = this.options.limit;
    if (n == null || n === 0) {
      e = true;
      return;
    }
    let i = this.storage.characters({ node: r.doc });
    if (i > n) {
      let s = i - n, a = 0, l = s;
      console.warn(`[CharacterCount] Initial content exceeded limit of ${n} characters. Content was automatically trimmed.`);
      let d = r.tr.deleteRange(a, l);
      return e = true, d;
    }
    e = true;
  }, filterTransaction: (t, o) => {
    let r = this.options.limit;
    if (!t.docChanged || r === 0 || r === null || r === void 0) return true;
    let n = this.storage.characters({ node: o.doc }), i = this.storage.characters({ node: t.doc });
    if (i <= r || n > r && i > r && i <= n) return true;
    if (n > r && i > r && i > n || !t.getMeta("paste")) return false;
    let a = t.selection.$head.pos, l = i - r, d = a - l, c = a;
    return t.deleteRange(d, c), !(this.storage.characters({ node: t.doc }) > r);
  } })];
} });
var Zo = Extension.create({ name: "dropCursor", addOptions() {
  return { color: "currentColor", width: 1, class: void 0 };
}, addProseMirrorPlugins() {
  return [dropCursor(this.options)];
} });
var pl = Extension.create({ name: "focus", addOptions() {
  return { className: "has-focus", mode: "all" };
}, addProseMirrorPlugins() {
  return [new Plugin({ key: new PluginKey("focus"), props: { decorations: ({ doc: e, selection: t }) => {
    let { isEditable: o, isFocused: r } = this.editor, { anchor: n } = t, i = [];
    if (!o || !r) return DecorationSet.create(e, []);
    let s = 0;
    this.options.mode === "deepest" && e.descendants((l, d) => {
      if (l.isText) return;
      if (!(n >= d && n <= d + l.nodeSize - 1)) return false;
      s += 1;
    });
    let a = 0;
    return e.descendants((l, d) => {
      if (l.isText || !(n >= d && n <= d + l.nodeSize - 1)) return false;
      if (a += 1, this.options.mode === "deepest" && s - a > 0 || this.options.mode === "shallowest" && a > 1) return this.options.mode === "deepest";
      i.push(Decoration.node(d, d + l.nodeSize, { class: this.options.className }));
    }), DecorationSet.create(e, i);
  } } })];
} });
var er = Extension.create({ name: "gapCursor", addProseMirrorPlugins() {
  return [gapCursor()];
}, extendNodeSchema(e) {
  var t;
  let o = { name: e.name, options: e.options, storage: e.storage };
  return { allowGapCursor: (t = callOrReturn(getExtensionField(e, "allowGapCursor", o))) != null ? t : null };
} });
var vl = Extension.create({ name: "placeholder", addOptions() {
  return { emptyEditorClass: "is-editor-empty", emptyNodeClass: "is-empty", placeholder: "Write something …", showOnlyWhenEditable: true, showOnlyCurrent: true, includeChildren: false };
}, addProseMirrorPlugins() {
  return [new Plugin({ key: new PluginKey("placeholder"), props: { decorations: ({ doc: e, selection: t }) => {
    let o = this.editor.isEditable || !this.options.showOnlyWhenEditable, { anchor: r } = t, n = [];
    if (!o) return null;
    let i = this.editor.isEmpty;
    return e.descendants((s, a) => {
      let l = r >= a && r <= a + s.nodeSize, d = !s.isLeaf && isNodeEmpty(s);
      if ((l || !this.options.showOnlyCurrent) && d) {
        let c = [this.options.emptyNodeClass];
        i && c.push(this.options.emptyEditorClass);
        let u = Decoration.node(a, a + s.nodeSize, { class: c.join(" "), "data-placeholder": typeof this.options.placeholder == "function" ? this.options.placeholder({ editor: this.editor, node: s, pos: a, hasAnchor: l }) : this.options.placeholder });
        n.push(u);
      }
      return this.options.includeChildren;
    }), DecorationSet.create(e, n);
  } } })];
} });
var Pl = Extension.create({ name: "selection", addOptions() {
  return { className: "selection" };
}, addProseMirrorPlugins() {
  let { editor: e, options: t } = this;
  return [new Plugin({ key: new PluginKey("selection"), props: { decorations(o) {
    return o.selection.empty || e.isFocused || !e.isEditable || isNodeSelection(o.selection) || e.view.dragging ? null : DecorationSet.create(o.doc, [Decoration.inline(o.selection.from, o.selection.to, { class: t.className })]);
  } } })];
} });
function Xo({ types: e, node: t }) {
  return t && Array.isArray(e) && e.includes(t.type) || (t == null ? void 0 : t.type) === e;
}
var tr = Extension.create({ name: "trailingNode", addOptions() {
  return { node: "paragraph", notAfter: [] };
}, addProseMirrorPlugins() {
  let e = new PluginKey(this.name), t = Object.entries(this.editor.schema.nodes).map(([, o]) => o).filter((o) => (this.options.notAfter || []).concat(this.options.node).includes(o.name));
  return [new Plugin({ key: e, appendTransaction: (o, r, n) => {
    let { doc: i, tr: s, schema: a } = n, l = e.getState(n), d = i.content.size, c = a.nodes[this.options.node];
    if (l) return s.insert(d, c.create());
  }, state: { init: (o, r) => {
    let n = r.tr.doc.lastChild;
    return !Xo({ node: n, types: t });
  }, apply: (o, r) => {
    if (!o.docChanged) return r;
    let n = o.doc.lastChild;
    return !Xo({ node: n, types: t });
  } } })];
} });
var or = Extension.create({ name: "undoRedo", addOptions() {
  return { depth: 100, newGroupDelay: 500 };
}, addCommands() {
  return { undo: () => ({ state: e, dispatch: t }) => undo(e, t), redo: () => ({ state: e, dispatch: t }) => redo(e, t) };
}, addProseMirrorPlugins() {
  return [history(this.options)];
}, addKeyboardShortcuts() {
  return { "Mod-z": () => this.editor.commands.undo(), "Shift-Mod-z": () => this.editor.commands.redo(), "Mod-y": () => this.editor.commands.redo(), "Mod-я": () => this.editor.commands.undo(), "Shift-Mod-я": () => this.editor.commands.redo() };
} });
var vs = Extension.create({ name: "starterKit", addExtensions() {
  var e, t, o, r;
  let n = [];
  return this.options.bold !== false && n.push(no.configure(this.options.bold)), this.options.blockquote !== false && n.push(eo.configure(this.options.blockquote)), this.options.bulletList !== false && n.push(zt.configure(this.options.bulletList)), this.options.code !== false && n.push(io.configure(this.options.code)), this.options.codeBlock !== false && n.push(lo.configure(this.options.codeBlock)), this.options.document !== false && n.push(co.configure(this.options.document)), this.options.dropcursor !== false && n.push(Zo.configure(this.options.dropcursor)), this.options.gapcursor !== false && n.push(er.configure(this.options.gapcursor)), this.options.hardBreak !== false && n.push(uo.configure(this.options.hardBreak)), this.options.heading !== false && n.push(po.configure(this.options.heading)), this.options.undoRedo !== false && n.push(or.configure(this.options.undoRedo)), this.options.horizontalRule !== false && n.push(ho.configure(this.options.horizontalRule)), this.options.italic !== false && n.push(fo.configure(this.options.italic)), this.options.listItem !== false && n.push($t.configure(this.options.listItem)), this.options.listKeymap !== false && n.push(jt.configure((e = this.options) == null ? void 0 : e.listKeymap)), this.options.link !== false && n.push(So.configure((t = this.options) == null ? void 0 : t.link)), this.options.orderedList !== false && n.push(Ut.configure(this.options.orderedList)), this.options.paragraph !== false && n.push(Vo.configure(this.options.paragraph)), this.options.strike !== false && n.push(qo.configure(this.options.strike)), this.options.text !== false && n.push(Yo.configure(this.options.text)), this.options.underline !== false && n.push(Qo.configure((o = this.options) == null ? void 0 : o.underline)), this.options.trailingNode !== false && n.push(tr.configure((r = this.options) == null ? void 0 : r.trailingNode)), n;
} });
var le = vs;
var Ts = `<svg width="18" height="18" viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M13.2427 4.75736L4.75739 13.2426" stroke="#0F1214" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M13.2427 13.2426L4.7574 4.75736" stroke="#0F1214" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`;
var _ = class _2 {
  constructor() {
    this.overlay = null;
    this.editorContainer = null;
    this.editor = null;
    this.extensions = [le];
    this.currentPageNumber = null;
    this.currentTarget = null;
    this.onContentChange = null;
    this.onClose = null;
    this.onHeightChange = null;
    this.resizeObserver = null;
    this.resizeDebounceTimer = null;
    this.toolbar = null;
    this.currentFooterType = "default";
    this.minContentHeight = 0;
    this.initialScrollY = 0;
    this.createOverlay();
  }
  static getInstance() {
    return _2.instance || (_2.instance = new _2()), _2.instance;
  }
  static destroy() {
    _2.instance && (_2.instance.cleanup(), _2.instance = null);
  }
  createOverlay() {
    this.overlay = document.createElement("div"), this.overlay.className = "tiptap-footer-editor-overlay", this.overlay.style.cssText = `
      position: absolute;
      display: none;
      z-index: 1000;
      background: white;
      box-sizing: border-box;
    `, this.editorContainer = document.createElement("div"), this.editorContainer.className = "tiptap-footer-editor-container", this.editorContainer.style.cssText = `
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
    `, this.overlay.appendChild(this.editorContainer), document.body.appendChild(this.overlay), this.createEditor(), this.overlay.addEventListener("keydown", (o) => {
      o.key === "Escape" && (o.preventDefault(), o.stopPropagation(), this.hide());
    });
    let t = (o) => o.stopPropagation();
    this.overlay.addEventListener("keydown", t, { capture: true }), this.overlay.addEventListener("keyup", t, { capture: true }), this.overlay.addEventListener("keypress", t, { capture: true }), this.overlay.addEventListener("mousedown", t), this.overlay.addEventListener("click", t);
  }
  createEditor() {
    var t;
    this.editorContainer && ((t = this.editor) == null || t.destroy(), this.editor = new Editor({ element: this.editorContainer, extensions: this.extensions, content: { type: "doc", content: [{ type: "paragraph" }] }, onUpdate: () => {
      this.onContentChange && this.onContentChange();
    } }), this.editor.on("blur", () => {
      setTimeout(() => {
        var o, r;
        if (((o = this.overlay) == null ? void 0 : o.style.display) !== "none") {
          let n = document.activeElement;
          (r = this.overlay) != null && r.contains(n) || this.hide();
        }
      }, 100);
    }));
  }
  configureExtensions(t) {
    t !== this.extensions && (this.extensions = t.length > 0 ? t : [le], this.createEditor());
  }
  show(t, o, r, n = {}) {
    var f;
    if (!this.overlay || !this.editor) return;
    this.currentPageNumber = o, this.currentTarget = t, this.currentFooterType = n.footerType || "default", this.onContentChange = n.onContentChange || null, this.onClose = n.onClose || null, this.onHeightChange = n.onHeightChange || null;
    let i = t.getBoundingClientRect(), s = window.scrollX, a = window.scrollY;
    this.initialScrollY = a;
    let l = window.getComputedStyle(t), d = parseFloat(l.paddingLeft) || 0, c = parseFloat(l.paddingRight) || 0, u = parseFloat(l.paddingBottom) || 0, h2 = i.height - u;
    this.minContentHeight = (f = n.baseMinHeight) != null ? f : h2;
    let m = i.bottom - u + a;
    this.overlay.style.left = `${i.left + s + d}px`, this.overlay.style.top = `${m}px`, this.overlay.style.bottom = "auto", this.overlay.style.transform = "translateY(-100%)", this.overlay.style.width = `${i.width - d - c}px`, this.overlay.style.minHeight = `${this.minContentHeight}px`, this.overlay.style.height = `${h2}px`, this.overlay.style.display = "block", this.overlay.style.padding = "0", this.editor.commands.setContent(r), setTimeout(() => {
      var v;
      (v = this.editor) == null || v.commands.focus("end");
    }, 0), this.createToolbar(o), this.setupResizeObserver();
  }
  createToolbar(t) {
    if (this.removeToolbar(), !this.overlay || !this.currentTarget) return;
    let o = window.getComputedStyle(this.currentTarget), r = (parseFloat(o.paddingLeft) || 0) - 1, n = Math.floor(parseFloat(o.paddingRight) || 0) - 1;
    this.toolbar = document.createElement("div"), this.toolbar.className = "tiptap-footer-edit-toolbar", this.toolbar.style.left = `-${r + 1}px`, this.toolbar.style.right = `-${n}px`;
    let i = document.createElement("span");
    i.className = "tiptap-footer-edit-label", i.textContent = this.getFooterLabel(t, this.currentFooterType);
    let s = document.createElement("div");
    s.className = "tiptap-footer-edit-actions";
    let a = document.createElement("button");
    a.className = "tiptap-footer-edit-close", a.innerHTML = Ts, a.type = "button", a.onclick = (l) => {
      l.preventDefault(), l.stopPropagation(), this.hide();
    }, s.appendChild(a), this.toolbar.appendChild(i), this.toolbar.appendChild(s), this.overlay.appendChild(this.toolbar);
  }
  removeToolbar() {
    var t;
    (t = this.toolbar) == null || t.remove(), this.toolbar = null;
  }
  getFooterLabel(t, o) {
    switch (o) {
      case "first":
        return "First page footer";
      case "odd":
        return "Odd pages footer";
      case "even":
        return "Even pages footer";
      default: {
        let r = ["th", "st", "nd", "rd"], n = t % 100;
        return `${t}${r[(n - 20) % 10] || r[n] || r[0]} page footer`;
      }
    }
  }
  setupResizeObserver() {
    var o;
    if (!this.overlay) return;
    let t = this.overlay.querySelector(".ProseMirror");
    t && ((o = this.resizeObserver) == null || o.disconnect(), this.resizeObserver = new ResizeObserver(() => {
      this.debouncedHeightChange();
    }), this.resizeObserver.observe(t));
  }
  debouncedHeightChange() {
    if (!this.overlay) return;
    let t = this.overlay.querySelector(".ProseMirror");
    if (!t || !t.lastElementChild) return;
    let o = t.getBoundingClientRect(), n = t.lastElementChild.getBoundingClientRect().bottom - o.top, i = Math.max(this.minContentHeight, n);
    this.overlay.style.height = `${i}px`, window.scrollTo(0, this.initialScrollY), this.onHeightChange && this.onHeightChange(n);
  }
  hide() {
    var n;
    if (!this.overlay || !this.editor) return;
    let t = this.currentPageNumber, o = this.overlay.querySelector(".ProseMirror"), r = 0;
    if (o && o.lastElementChild) {
      let i = o.getBoundingClientRect();
      r = o.lastElementChild.getBoundingClientRect().bottom - i.top;
    }
    (n = this.resizeObserver) == null || n.disconnect(), this.resizeObserver = null, this.resizeDebounceTimer && (window.clearTimeout(this.resizeDebounceTimer), this.resizeDebounceTimer = null), this.removeToolbar(), this.overlay.style.display = "none", t !== null && this.onClose && this.onClose(t, r), this.currentPageNumber = null, this.currentTarget = null, this.onContentChange = null, this.onClose = null, this.onHeightChange = null;
  }
  getHTML() {
    var t;
    return ((t = this.editor) == null ? void 0 : t.getHTML()) || "";
  }
  normalizeHTML(t) {
    if (!this.editor || !t.trim()) return "<p></p>";
    this.editor.commands.setContent(t);
    let o = this.editor.getHTML();
    return this.editor.commands.setContent({ type: "doc", content: [{ type: "paragraph" }] }), o;
  }
  isVisible() {
    var t;
    return ((t = this.overlay) == null ? void 0 : t.style.display) !== "none";
  }
  getEditor() {
    return this.editor;
  }
  cleanup() {
    var t, o;
    (t = this.editor) == null || t.destroy(), (o = this.overlay) == null || o.remove(), this.editor = null, this.overlay = null;
  }
};
_.instance = null;
var oe = _;
function rr() {
  let e = "tiptap-footer-editor-overlay-styles";
  if (document.getElementById(e)) return;
  let t = document.createElement("style");
  t.id = e, t.textContent = `
    .tiptap-footer-editor-overlay {
      /* position: absolute is set inline */
    }

    .tiptap-footer-editor-overlay .tiptap-footer-editor-container {
      /* Absolute positioning at bottom - content grows upward naturally */
    }

    .tiptap-footer-editor-overlay .tiptap {
      outline: none;
      min-height: 1em;
      padding: 0;
      margin: 0;
    }

    .tiptap-footer-editor-overlay .tiptap p {
      margin: 0;
      padding: 0;
    }

    .tiptap-footer-editor-overlay .tiptap:focus {
      outline: none;
    }

    .tiptap-footer-editor-overlay .ProseMirror {
      padding: 0 !important;
      margin: 0 !important;
      caret-color: #6366f1;
    }

    /* Toolbar - positioned at TOP edge of overlay, translated UP */
    .tiptap-footer-edit-toolbar {
      position: absolute;
      top: 0px;
      /* left/right set inline to extend to page borders */
      transform: translateY(-100%);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 2px solid #6366f1;
      background: white;
      z-index: 1001;
      will-change: transform;
      transition: transform 0.2s ease-in-out;
    }

    /* Label on the left - border radius at top for footer */
    .tiptap-footer-edit-label {
      position: relative;
      bottom: -2px;
      background: #6366f1;
      color: white;
      font-size: 11px;
      padding: 3px 10px;
      font-family: system-ui, sans-serif;
      font-weight: 500;
      border-top-right-radius: 4px;
      border-top-left-radius: 4px;
    }

    /* Actions container on the right */
    .tiptap-footer-edit-actions {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 2px 4px;
    }

    /* Close button */
    .tiptap-footer-edit-close {
      background: transparent;
      border: none;
      color: #6b7280;
      cursor: pointer;
      margin: 0;
      padding: 2px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .tiptap-footer-edit-close:hover {
      color: #374151;
    }
  `, document.head.appendChild(t);
}
var Ps = `<svg width="18" height="18" viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M13.2427 4.75736L4.75739 13.2426" stroke="#0F1214" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M13.2427 13.2426L4.7574 4.75736" stroke="#0F1214" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`;
var j = class j2 {
  constructor() {
    this.overlay = null;
    this.editorContainer = null;
    this.editor = null;
    this.extensions = [le];
    this.currentPageNumber = null;
    this.currentTarget = null;
    this.onContentChange = null;
    this.onClose = null;
    this.onHeightChange = null;
    this.resizeObserver = null;
    this.resizeDebounceTimer = null;
    this.toolbar = null;
    this.currentHeaderType = "default";
    this.minContentHeight = 0;
    this.initialScrollY = 0;
    this.createOverlay();
  }
  static getInstance() {
    return j2.instance || (j2.instance = new j2()), j2.instance;
  }
  static destroy() {
    j2.instance && (j2.instance.cleanup(), j2.instance = null);
  }
  createOverlay() {
    this.overlay = document.createElement("div"), this.overlay.className = "tiptap-header-editor-overlay", this.overlay.style.cssText = `
      position: absolute;
      display: none;
      z-index: 1000;
      background: white;
      box-sizing: border-box;
    `, this.editorContainer = document.createElement("div"), this.editorContainer.className = "tiptap-header-editor-container", this.overlay.appendChild(this.editorContainer), document.body.appendChild(this.overlay), this.createEditor(), this.overlay.addEventListener("keydown", (o) => {
      o.key === "Escape" && (o.preventDefault(), o.stopPropagation(), this.hide());
    });
    let t = (o) => o.stopPropagation();
    this.overlay.addEventListener("keydown", t, { capture: true }), this.overlay.addEventListener("keyup", t, { capture: true }), this.overlay.addEventListener("keypress", t, { capture: true }), this.overlay.addEventListener("mousedown", t), this.overlay.addEventListener("click", t);
  }
  createEditor() {
    var t;
    this.editorContainer && ((t = this.editor) == null || t.destroy(), this.editor = new Editor({ element: this.editorContainer, extensions: this.extensions, content: { type: "doc", content: [{ type: "paragraph" }] }, onUpdate: () => {
      this.onContentChange && this.onContentChange();
    } }), this.editor.on("blur", () => {
      setTimeout(() => {
        var o, r;
        if (((o = this.overlay) == null ? void 0 : o.style.display) !== "none") {
          let n = document.activeElement;
          (r = this.overlay) != null && r.contains(n) || this.hide();
        }
      }, 100);
    }));
  }
  configureExtensions(t) {
    t !== this.extensions && (this.extensions = t.length > 0 ? t : [le], this.createEditor());
  }
  show(t, o, r, n = {}) {
    var m;
    if (!this.overlay || !this.editor) return;
    this.currentPageNumber = o, this.currentTarget = t, this.currentHeaderType = n.headerType || "default", this.onContentChange = n.onContentChange || null, this.onClose = n.onClose || null, this.onHeightChange = n.onHeightChange || null;
    let i = t.getBoundingClientRect(), s = window.scrollX, a = window.scrollY;
    this.initialScrollY = a;
    let l = window.getComputedStyle(t), d = parseFloat(l.paddingLeft) || 0, c = parseFloat(l.paddingRight) || 0, u = parseFloat(l.paddingTop) || 0, h2 = i.height - u;
    this.minContentHeight = (m = n.baseMinHeight) != null ? m : h2, this.overlay.style.left = `${i.left + s + d}px`, this.overlay.style.top = `${i.top + a + u}px`, this.overlay.style.width = `${i.width - d - c}px`, this.overlay.style.minHeight = `${this.minContentHeight}px`, this.overlay.style.height = `${h2}px`, this.overlay.style.display = "block", this.overlay.style.padding = "0", this.editor.commands.setContent(r), setTimeout(() => {
      var f;
      (f = this.editor) == null || f.commands.focus("end");
    }, 0), this.createToolbar(o), this.setupResizeObserver();
  }
  createToolbar(t) {
    if (this.removeToolbar(), !this.overlay || !this.currentTarget) return;
    let o = window.getComputedStyle(this.currentTarget), r = (parseFloat(o.paddingLeft) || 0) - 1, n = Math.floor(parseFloat(o.paddingRight) || 0) - 1;
    this.toolbar = document.createElement("div"), this.toolbar.className = "tiptap-header-edit-toolbar", this.toolbar.style.left = `-${r + 1}px`, this.toolbar.style.right = `-${n}px`;
    let i = document.createElement("span");
    i.className = "tiptap-header-edit-label", i.textContent = this.getHeaderLabel(t, this.currentHeaderType);
    let s = document.createElement("div");
    s.className = "tiptap-header-edit-actions";
    let a = document.createElement("button");
    a.className = "tiptap-header-edit-close", a.innerHTML = Ps, a.type = "button", a.onclick = (l) => {
      l.preventDefault(), l.stopPropagation(), this.hide();
    }, s.appendChild(a), this.toolbar.appendChild(i), this.toolbar.appendChild(s), this.overlay.appendChild(this.toolbar);
  }
  removeToolbar() {
    var t;
    (t = this.toolbar) == null || t.remove(), this.toolbar = null;
  }
  getHeaderLabel(t, o) {
    switch (o) {
      case "first":
        return "First page header";
      case "odd":
        return "Odd pages header";
      case "even":
        return "Even pages header";
      default: {
        let r = ["th", "st", "nd", "rd"], n = t % 100;
        return `${t}${r[(n - 20) % 10] || r[n] || r[0]} page header`;
      }
    }
  }
  setupResizeObserver() {
    var o;
    if (!this.overlay) return;
    let t = this.overlay.querySelector(".ProseMirror");
    t && ((o = this.resizeObserver) == null || o.disconnect(), this.resizeObserver = new ResizeObserver(() => {
      this.debouncedHeightChange();
    }), this.resizeObserver.observe(t));
  }
  debouncedHeightChange() {
    if (!this.overlay) return;
    let t = this.overlay.querySelector(".ProseMirror");
    if (!t || !t.lastElementChild) return;
    let o = t.getBoundingClientRect(), n = t.lastElementChild.getBoundingClientRect().bottom - o.top, i = Math.max(this.minContentHeight, n);
    this.overlay.style.height = `${i}px`, window.scrollTo(0, this.initialScrollY), this.onHeightChange && this.onHeightChange(n);
  }
  hide() {
    var n;
    if (!this.overlay || !this.editor) return;
    let t = this.currentPageNumber, o = this.overlay.querySelector(".ProseMirror"), r = 0;
    if (o && o.lastElementChild) {
      let i = o.getBoundingClientRect();
      r = o.lastElementChild.getBoundingClientRect().bottom - i.top;
    }
    (n = this.resizeObserver) == null || n.disconnect(), this.resizeObserver = null, this.resizeDebounceTimer && (window.clearTimeout(this.resizeDebounceTimer), this.resizeDebounceTimer = null), this.removeToolbar(), this.overlay.style.display = "none", t !== null && this.onClose && this.onClose(t, r), this.currentPageNumber = null, this.currentTarget = null, this.onContentChange = null, this.onClose = null, this.onHeightChange = null;
  }
  getHTML() {
    var t;
    return ((t = this.editor) == null ? void 0 : t.getHTML()) || "";
  }
  normalizeHTML(t) {
    if (!this.editor || !t.trim()) return "<p></p>";
    this.editor.commands.setContent(t);
    let o = this.editor.getHTML();
    return this.editor.commands.setContent({ type: "doc", content: [{ type: "paragraph" }] }), o;
  }
  isVisible() {
    var t;
    return ((t = this.overlay) == null ? void 0 : t.style.display) !== "none";
  }
  getEditor() {
    return this.editor;
  }
  cleanup() {
    var t, o;
    (t = this.editor) == null || t.destroy(), (o = this.overlay) == null || o.remove(), this.editor = null, this.overlay = null;
  }
};
j.instance = null;
var re = j;
function nr() {
  let e = "tiptap-header-editor-overlay-styles";
  if (document.getElementById(e)) return;
  let t = document.createElement("style");
  t.id = e, t.textContent = `
    .tiptap-header-editor-overlay {
      /* position: absolute is set inline */
    }

    .tiptap-header-editor-overlay .tiptap-header-editor-container {
      width: 100%;
      min-height: 100%;
    }

    .tiptap-header-editor-overlay .tiptap {
      outline: none;
      min-height: 1em;
      padding: 0;
      margin: 0;
    }

    .tiptap-header-editor-overlay .tiptap p {
      margin: 0;
      padding: 0;
    }

    .tiptap-header-editor-overlay .tiptap:focus {
      outline: none;
    }

    .tiptap-header-editor-overlay .ProseMirror {
      padding: 0 !important;
      margin: 0 !important;
      caret-color: #6366f1;
    }

    /* Toolbar - positioned at bottom edge of overlay, translated down */
    .tiptap-header-edit-toolbar {
      position: absolute;
      bottom: 0px;
      /* left/right set inline to extend to page borders */
      transform: translateY(100%);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-top: 2px solid #6366f1;
      background: white;
      z-index: 1001;
    }

    /* Label on the left */
    .tiptap-header-edit-label {
      position: relative;
      top: -2px;
      background: #6366f1;
      color: white;
      font-size: 11px;
      padding: 3px 10px;
      font-family: system-ui, sans-serif;
      font-weight: 500;
      border-bottom-right-radius: 4px;
      border-bottom-left-radius: 4px;
    }

    /* Actions container on the right */
    .tiptap-header-edit-actions {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 2px 4px;
    }

    /* Close button */
    .tiptap-header-edit-close {
      background: transparent;
      border: none;
      color: #6b7280;
      cursor: pointer;
      margin: 0;
      padding: 2px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .tiptap-header-edit-close:hover {
      color: #374151;
    }
  `, document.head.appendChild(t);
}
function ke(e, t) {
  return e === 1 && t.differentFirstPage ? "first" : t.differentOddEven ? e % 2 === 1 ? "odd" : "even" : "default";
}
function J(e, t) {
  return e === 1 && t.differentFirstPageFooter ? "first" : t.differentOddEvenFooter ? e % 2 === 1 ? "odd" : "even" : "default";
}
var ne = [];
var ir = 0;
var Kt = null;
var ks = 2e3;
function sr(e, t) {
  let o = Date.now();
  if (o < ir && Kt != null) return { stop: true, stablePageCount: Kt };
  if (ne.push({ pageCount: e, gap: t }), ne.length > 4 && ne.shift(), ne.length === 4) {
    let r = ne[0], n = ne[3], i = n.pageCount > r.pageCount, s = Math.abs(n.gap - r.gap) < 50;
    if (i && s) {
      let a = Math.max(1, r.pageCount);
      return ne.length = 0, ir = o + ks, Kt = a, { stop: true, stablePageCount: a };
    }
  }
  return { stop: false };
}
function de(e) {
  let o = e.dom.querySelector("[data-tiptap-pagination]");
  return o ? o.children.length : 0;
}
function lr() {
  return typeof window != "undefined" && window.devicePixelRatio ? Math.round(96 * window.devicePixelRatio) : 96;
}
function E(e, t = lr()) {
  return e * t / 2.54;
}
var Ce = { A4: { id: "A4", width: E(21, 96), height: E(29.7, 96), margins: { top: E(2.5, 96), right: E(2, 96), bottom: E(2.5, 96), left: E(2, 96) } }, A3: { id: "A3", width: E(29.7, 96), height: E(42, 96), margins: { top: E(2.5, 96), right: E(2, 96), bottom: E(2.5, 96), left: E(2, 96) } }, A5: { id: "A5", width: E(14.8, 96), height: E(21, 96), margins: { top: E(2, 96), right: E(1.5, 96), bottom: E(2, 96), left: E(1.5, 96) } }, Letter: { id: "Letter", width: E(21.59, 96), height: E(27.94, 96), margins: { top: E(2.54, 96), right: E(2.54, 96), bottom: E(2.54, 96), left: E(2.54, 96) } }, Legal: { id: "Legal", width: E(21.59, 96), height: E(35.56, 96), margins: { top: E(2.54, 96), right: E(2.54, 96), bottom: E(2.54, 96), left: E(2.54, 96) } }, Tabloid: { id: "Tabloid", width: E(27.94, 96), height: E(43.18, 96), margins: { top: E(2.54, 96), right: E(2.54, 96), bottom: E(2.54, 96), left: E(2.54, 96) } } };
function N(e) {
  var n, i, s, a;
  let t = typeof e.pageFormat == "string" ? Ce[e.pageFormat] : e.pageFormat, o = t.margins.top * 0.5, r = t.margins.bottom * 0.5;
  return { width: t.width, height: t.height, margins: t.margins, headerTopMargin: (n = e.headerTopMargin) != null ? n : o, footerBottomMargin: (i = e.footerBottomMargin) != null ? i : r, pageGap: (s = e.pageGap) != null ? s : 50, footer: e.footer, header: e.header, pageBreakBackground: (a = e.pageBreakBackground) != null ? a : "#fff" };
}
function dr(e, t, o) {
  var a, l, d, c, u, h2, m, f;
  let r = ke(e, o), n = J(e, o), i = 0;
  switch (r) {
    case "first":
      i = (a = o.headerFirstPageContentHeight) != null ? a : 0;
      break;
    case "odd":
      i = (l = o.headerOddContentHeight) != null ? l : 0;
      break;
    case "even":
      i = (d = o.headerEvenContentHeight) != null ? d : 0;
      break;
    default:
      i = (c = o.headerContentHeight) != null ? c : 0;
  }
  let s = 0;
  switch (n) {
    case "first":
      s = (u = o.footerFirstPageContentHeight) != null ? u : 0;
      break;
    case "odd":
      s = (h2 = o.footerOddContentHeight) != null ? h2 : 0;
      break;
    case "even":
      s = (m = o.footerEvenContentHeight) != null ? m : 0;
      break;
    default:
      s = (f = o.footerContentHeight) != null ? f : 0;
  }
  return t.height - t.margins.top - t.margins.bottom - i - s;
}
function ce({ view: e, options: t, storage: o }) {
  var c, u;
  let r = N({ ...t, pageFormat: o.pageFormat, pageGap: o.pageGap, headerTopMargin: o.headerTopMargin, footerBottomMargin: o.footerBottomMargin, footer: o.footer, header: o.header, pageBreakBackground: o.pageBreakBackground }), n = e.dom, i = n.querySelector("[data-tiptap-pagination]"), s = de(e);
  if (i) {
    let h2 = n.lastElementChild, m = (c = i.lastElementChild) == null ? void 0 : c.querySelector(".breaker");
    if (h2 && m) {
      let f = h2.getBoundingClientRect().bottom - m.getBoundingClientRect().bottom, v = sr(s, f);
      if (v.stop) return console.warn(`[Pages] A non-floatable element exceeds page height limits, this can cause pagination break.

Find out how to fix this: https://tiptap.dev/docs/pages/core-concepts/limitations

Read more about non-floating elements here: https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context`), Math.max(1, (u = v.stablePageCount) != null ? u : s);
      if (f > 0) {
        let b = f, x = 0, k = s + 1;
        for (; b > 0; ) {
          let P = dr(k, r, o);
          b -= P, x++, k++;
        }
        return Math.max(1, s + x);
      }
      let T = -10, g = -(r.height - 10);
      if (f > g && f < T) return Math.max(1, s);
      if (f < g) {
        let b = r.height + 50, x = Math.floor(f / b);
        return Math.max(1, s + x);
      }
      return Math.max(1, s);
    }
    return 1;
  }
  let a = n.scrollHeight, l = 0, d = 0;
  for (; l < a; ) d++, l += dr(d, r, o);
  return Math.max(1, d);
}
var it = (e) => {
  var o;
  let t = e.querySelector("[data-tiptap-pagination]");
  if (t) {
    let r = (o = t.lastElementChild) == null ? void 0 : o.querySelector(".breaker");
    if (r) {
      let n = r.offsetTop + r.offsetHeight;
      e.style.minHeight = `${n}px`;
    }
  }
};
var Hs = "PAGE_COUNT_META_KEY";
var ue = null;
function cr({ view: e, options: t, storage: o }) {
  let r = (n) => {
    if (n.length > 0 && n[0].target) {
      let i = n[0].target;
      if (i.classList.contains(o.uniqueId)) {
        let s = de(e), a = ce({ view: e, options: t, storage: o });
        if (s !== a) {
          let l = e.state.tr.setMeta(Hs, Date.now());
          e.dispatch(l);
        }
        it(i);
      }
    }
  };
  ue || (ue = new MutationObserver(r), ue.observe(e.dom, { attributes: true }));
}
function ur() {
  ue && (ue.disconnect(), ue = null);
}
function H({ view: e, options: t, storage: o }) {
  var u, h2, m, f, v, T, g, b, x, k, P, M, F, G, ie, V;
  let r = e.dom;
  r.classList.contains(o.uniqueId) || r.classList.add(o.uniqueId);
  let n = N({ ...t, pageFormat: o.pageFormat, pageGap: o.pageGap, headerTopMargin: o.headerTopMargin, footerBottomMargin: o.footerBottomMargin, footer: o.footer, header: o.header, pageBreakBackground: o.pageBreakBackground });
  o.styleElement && o.styleElement.parentNode && o.styleElement.parentNode.removeChild(o.styleElement);
  let i = document.createElement("style");
  i.dataset.tiptapPaginationStyle = o.uniqueId;
  let s = `.${o.uniqueId}`, a = 20, l = 0;
  o.differentOddEven ? o.differentFirstPage ? l = Math.max((u = o.headerFirstPageContentHeight) != null ? u : 0, (h2 = o.headerOddContentHeight) != null ? h2 : 0, (m = o.headerEvenContentHeight) != null ? m : 0) : l = Math.max((f = o.headerOddContentHeight) != null ? f : 0, (v = o.headerEvenContentHeight) != null ? v : 0) : o.differentFirstPage ? l = Math.max((T = o.headerFirstPageContentHeight) != null ? T : 0, (g = o.headerContentHeight) != null ? g : 0) : l = (b = o.headerContentHeight) != null ? b : 0;
  let d = 0;
  o.differentOddEvenFooter ? o.differentFirstPageFooter ? d = Math.max((x = o.footerFirstPageContentHeight) != null ? x : 0, (k = o.footerOddContentHeight) != null ? k : 0, (P = o.footerEvenContentHeight) != null ? P : 0) : d = Math.max((M = o.footerOddContentHeight) != null ? M : 0, (F = o.footerEvenContentHeight) != null ? F : 0) : o.differentFirstPageFooter ? d = Math.max((G = o.footerFirstPageContentHeight) != null ? G : 0, (ie = o.footerContentHeight) != null ? ie : 0) : d = (V = o.footerContentHeight) != null ? V : 0;
  let c = n.height - n.margins.top - n.margins.bottom - l - d - a;
  r.style.setProperty("--page-max-height", `${c}px`), i.textContent = `
        ${s} {
          width: ${n.width}px;
          margin: 50px auto;
          background-color: #fff;
          border: 1px solid #e5e5e5;
          padding: 0px ${n.margins.right}px 0px ${n.margins.left}px;
          box-sizing: border-box;
        }

        /* Give everything that falls within the pagination container a border-box box-sizing */
        /* This helps with consistent sizing and layout calculations */
        ${s} * {
          box-sizing: border-box;
        }

        /* Give a remote user a caret */
        ${s} .collaboration-carets__caret {
          border-left: 1px solid #0d0d0d;
          border-right: 1px solid #0d0d0d;
          margin-left: -1px;
          margin-right: -1px;
          pointer-events: none;
          position: relative;
          word-break: normal;
        }

        /* Render the username above the caret */
        ${s} .collaboration-carets__label {
          border-radius: 3px 3px 3px 0;
          color: #0d0d0d;
          font-size: 12px;
          font-style: normal;
          font-weight: 600;
          left: -1px;
          line-height: normal;
          padding: 0.1rem 0.3rem;
          position: absolute;
          top: -1.4em;
          user-select: none;
          white-space: nowrap;
        }

        ${s} .tiptap-pagination-gap {
          border-top: 1px solid #e5e5e5;
          border-bottom: 1px solid #e5e5e5;
        }

        ${s} .tiptap-page-footer::after {
          color: #6b7280; /* Tailwind text-gray-500 */
        }

        ${s} .tiptap-page-footer {
          background-color: hsl(var(--background));
          display: block;
          width: 100%;
          box-sizing: border-box;
          color: #6b7280;
        }

        ${s} .tiptap-page-header {
          background-color: hsl(var(--background));
          display: flex;
          flex-direction: column;
          width: 100%;
          box-sizing: border-box;
          color: #6b7280;
        }

        ${s} .tiptap-page-footer {
          background-color: hsl(var(--background));
          display: flex;
          flex-direction: column;
          width: 100%;
          box-sizing: border-box;
          color: #6b7280;
        }

        ${s} .tiptap-page-header p,
        ${s} .tiptap-page-footer p {
          margin: 0;
        }

        /* Maintain height for empty paragraphs (match editor's <br> behavior) */
        ${s} .tiptap-page-header p:empty::before,
        ${s} .tiptap-page-footer p:empty::before {
          content: '\\00a0';
          display: inline;
        }

        ${s} .tiptap-page-header-center,
        ${s} .tiptap-page-footer-center {
          flex: 1;
          text-align: center;
        }

        ${s} {
          counter-reset: page-number;
        }

        ${s} .tiptap-page-footer {
          counter-increment: page-number;
        }

        ${s} .tiptap-page-break:last-child .tiptap-pagination-gap {
          display: none;
        }

        ${s} .tiptap-page-break:last-child .tiptap-page-header {
          display: none;
        }

        ${s} p:has(br.ProseMirror-trailingBreak:only-child) {
          display: table; /* Fallback for older browsers */
          display: flow-root;
          width: 100%;
        }

        ${s} .tiptap-page-number::before {
          content: counter(page-number);
        }

        ${s} .tiptap-first-page-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          width: 100%;
        }

        ${s} .tiptap-page-header-center {
          flex: 1;
          text-align: center;
        }

        ${s} table {
          border-collapse: collapse;
          width: 100%;
          display: contents;
        }

        ${s} table tbody {
          width: 100%;
          display: contents;
        }

        ${s} table tbody tr, ${s} table tr {
          width: 100%;
          position: relative;
          box-sizing: border-box;
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(0, 1fr));
        }

        ${s} table tbody tr td,
        ${s} table tbody tr th,
        ${s} table tr td,
        ${s} table tr th {
          box-sizing: border-box;
          position: relative;
        }
      `, document.head.appendChild(i), o.styleElement = i, cr({ view: e, options: t, storage: o }), it(e.dom);
}
function st(e, t, o) {
  if (!o[t]) {
    let r = typeof e == "function" ? e(1, 1) : e, n = re.getInstance();
    o[t] = n.normalizeHTML(r);
  }
  return o[t];
}
function at(e, t, o) {
  if (!o[t]) {
    let r = typeof e == "function" ? e(1, 1) : e, n = oe.getInstance();
    o[t] = n.normalizeHTML(r);
  }
  return o[t];
}
function Ls(e, t, o, r, n) {
  let i;
  switch (e) {
    case "first": {
      if (r.headerFirstPageHTML) i = r.headerFirstPageHTML;
      else {
        let s = r.headerFirstPage || n.header;
        i = st(s, "normalizedFirstPageTemplate", r);
      }
      break;
    }
    case "odd": {
      if (r.headerOddHTML) i = r.headerOddHTML;
      else {
        let s = r.headerOdd || n.header;
        i = st(s, "normalizedOddTemplate", r);
      }
      break;
    }
    case "even": {
      if (r.headerEvenHTML) i = r.headerEvenHTML;
      else {
        let s = r.headerEven || n.header;
        i = st(s, "normalizedEvenTemplate", r);
      }
      break;
    }
    default: {
      r.headerHTML ? i = r.headerHTML : i = st(n.header, "normalizedHeaderTemplate", r);
      break;
    }
  }
  return i.replace(/{page}/g, `${t}`).replace(/{total}/g, `${o}`);
}
function Ms(e, t, o, r, n) {
  let i;
  switch (e) {
    case "first": {
      if (r.footerFirstPageHTML) i = r.footerFirstPageHTML;
      else {
        let s = r.footerFirstPage || n.footer;
        i = at(s, "normalizedFirstPageFooterTemplate", r);
      }
      break;
    }
    case "odd": {
      if (r.footerOddHTML) i = r.footerOddHTML;
      else {
        let s = r.footerOdd || n.footer;
        i = at(s, "normalizedOddFooterTemplate", r);
      }
      break;
    }
    case "even": {
      if (r.footerEvenHTML) i = r.footerEvenHTML;
      else {
        let s = r.footerEven || n.footer;
        i = at(s, "normalizedEvenFooterTemplate", r);
      }
      break;
    }
    default: {
      r.footerHTML ? i = r.footerHTML : i = at(n.footer, "normalizedFooterTemplate", r);
      break;
    }
  }
  return i.replace(/{page}/g, `${t}`).replace(/{total}/g, `${o}`);
}
function pr(e, t) {
  var o, r, n, i;
  switch (e) {
    case "first":
      return (o = t.headerFirstPageContentHeight) != null ? o : 0;
    case "odd":
      return (r = t.headerOddContentHeight) != null ? r : 0;
    case "even":
      return (n = t.headerEvenContentHeight) != null ? n : 0;
    default:
      return (i = t.headerContentHeight) != null ? i : 0;
  }
}
function Wt(e, t) {
  var o, r, n, i;
  switch (e) {
    case "first":
      return (o = t.footerFirstPageContentHeight) != null ? o : 0;
    case "odd":
      return (r = t.footerOddContentHeight) != null ? r : 0;
    case "even":
      return (n = t.footerEvenContentHeight) != null ? n : 0;
    default:
      return (i = t.footerContentHeight) != null ? i : 0;
  }
}
function Gt({ options: e, storage: t, pageCount: o }) {
  let r = N({ ...e, pageFormat: t.pageFormat, pageGap: t.pageGap, headerTopMargin: t.headerTopMargin, footerBottomMargin: t.footerBottomMargin, footer: t.footer, header: t.header, pageBreakBackground: t.pageBreakBackground });
  return [Decoration.widget(0, (i) => {
    var f;
    let s = r.pageGap, a = (f = r.pageBreakBackground) != null ? f : "#ffffff", l = r.width, d = document.createElement("div");
    d.dataset.tiptapPagination = "true";
    let c = ({ firstPage: v = false, pageNumber: T = 0, totalPages: g = 0 }) => {
      let b = ke(T, t), x = pr(b, t), k = J(T, t), P = Wt(k, t), M = r.height - r.margins.top - r.margins.bottom - x - P, F = T + 1, G = ke(F, t), ie = pr(G, t), V = J(T, t), ct = Wt(V, t), X = document.createElement("div");
      X.classList.add("tiptap-page-break");
      let O, A, Z, S = document.createElement("div");
      S.classList.add("page"), S.style.position = "relative", S.style.float = "left", S.style.clear = "both", S.style.marginTop = v ? "0px" : `${M}px`, S.dataset.pageNumber = T.toString();
      let w = document.createElement("div");
      if (w.classList.add("breaker"), w.style.width = `calc(${l}px)`, w.style.marginLeft = `-${r.margins.left}px`, w.style.position = "relative", w.style.float = "left", w.style.clear = "both", w.style.left = "0px", w.style.right = "0px", w.style.zIndex = "2", w.dataset.pageNumber = T.toString(), !v) {
        O = document.createElement("div"), O.classList.add("tiptap-page-footer");
        let se = J(T, t), Er = Wt(se, t), qt = r.margins.bottom + Er;
        O.style.minHeight = `${qt}px`, O.style.height = `${qt}px`, O.style.padding = `0 ${r.margins.right}px ${r.footerBottomMargin}px ${r.margins.left}px`, O.style.display = "flex", O.style.flexDirection = "column", O.style.justifyContent = "flex-end", O.dataset.editable = "true", O.dataset.footerPageNumber = T.toString(), O.dataset.footerType = se, O.style.cursor = "pointer", Z = Ms(se, T, g, t, r), O.innerHTML = Z, A = document.createElement("div"), A.classList.add("tiptap-pagination-gap"), A.style.height = `${s}px`, A.style.borderLeft = "1px solid", A.style.borderRight = "1px solid", A.style.position = "relative", A.style.setProperty("width", "calc(100% + 2px)", "important"), A.style.left = "-1px", A.style.backgroundColor = a, A.style.borderLeftColor = a, A.style.borderRightColor = a;
      }
      let B = document.createElement("div");
      B.classList.add("tiptap-page-header");
      let Vt = r.margins.top + ie;
      B.style.minHeight = `${Vt}px`, B.style.height = `${Vt}px`, B.style.padding = `${r.headerTopMargin}px ${r.margins.right}px 0 ${r.margins.left}px`, B.dataset.editable = "true", B.dataset.headerPageNumber = F.toString(), B.dataset.headerType = G, B.style.cursor = "pointer";
      let yr = Ls(G, F, g, t, r);
      B.innerHTML = yr;
      let Tr = v ? [B] : [O, A, B];
      for (let se of Tr) se && w.append(se);
      return X.append(S, w), X;
    }, u = document.createDocumentFragment(), h2 = o != null ? o : ce({ view: i, options: e, storage: t }), m = 0;
    for (; m < h2; ) {
      let v = c({ firstPage: m === 0, lastPage: false, pageNumber: m, totalPages: h2 - 1 });
      v.dataset.pageNumber = m.toString(), u.appendChild(v.cloneNode(true)), m += 1;
    }
    return d.append(u), d.id = "pages", d;
  }, { side: -1 })];
}
var lt = class {
  getNodesOnPage(t, o) {
    let r = o.dom, n = r.querySelector("[data-tiptap-pagination]");
    if (!n) return t === 1 ? this.getAllNodesOnSinglePage(o, 1) : [];
    let i = this.getPageBreakPositions(r, n);
    if (!i.length) return t === 1 ? this.getAllNodesOnSinglePage(o, 1) : [];
    let s = [];
    return o.state.doc.descendants((a, l) => {
      if (!a.isBlock) return true;
      let d = this.calculateNodePage(a, l, i, o, r);
      return d === t ? (s.push({ node: a, pos: l, page: d }), false) : true;
    }), s;
  }
  getPageForPosition(t, o, r = false) {
    let n = o.dom, i = n.querySelector("[data-tiptap-pagination]");
    if (r && console.log(`[PageTracker] getPageForPosition - pos: ${t}, paginationContainer found:`, !!i), !i) return r && console.log("[PageTracker] No pagination container, returning page 1"), 1;
    let s = this.getPageBreakPositions(n, i);
    if (r && console.log("[PageTracker] Page break positions:", s), !s.length) return r && console.log("[PageTracker] No page breaks, returning page 1"), 1;
    let a = this.calculatePageForPosition(t, s, o, n, r);
    return r && console.log(`[PageTracker] Calculated page: ${a}`), a;
  }
  getCurrentPage(t, o = false) {
    let { from: r } = t.state.selection;
    o && console.log(`[PageTracker] getCurrentPage - cursor position: ${r}`);
    let n = this.getPageForPosition(r, t, o);
    return o && console.log(`[PageTracker] getCurrentPage - calculated page: ${n}`), n;
  }
  getPageCount(t) {
    let r = t.dom.querySelector("[data-tiptap-pagination]");
    return r ? Array.from(r.querySelectorAll(".breaker")).length + 1 : 1;
  }
  getPages(t) {
    let o = this.getPageCount(t), r = [];
    for (let n = 1; n <= o; n++) this.getNodesOnPage(n, t).length > 0 && r.push(n);
    return r;
  }
  doesRangeSpanPages(t, o, r) {
    let n = this.getPageForPosition(t, r), i = this.getPageForPosition(o, r);
    if (n === i) return { spans: false, pages: [n] };
    let s = [];
    for (let a = n; a <= i; a++) s.push(a);
    return { spans: true, pages: s };
  }
  getPageStats(t) {
    let o = this.getPageCount(t), r = this.getPages(t), n = {}, i = 0;
    for (let a of r) {
      let l = this.getNodesOnPage(a, t).length;
      n[a] = l, i += l;
    }
    let s = o > 0 ? i / o : 0;
    return { totalPages: o, totalNodes: i, nodesPerPage: n, averageNodesPerPage: Math.round(s * 100) / 100 };
  }
  getAllNodesWithPages(t) {
    let o = [], r = this.getPages(t);
    for (let n of r) {
      let i = this.getNodesOnPage(n, t);
      o.push(...i);
    }
    return o.sort((n, i) => n.pos - i.pos);
  }
  getClosestNodeOnSamePage(t, o) {
    let r = this.getPageForPosition(t, o), n = this.getNodesOnPage(r, o);
    if (n.length === 0) return;
    let i = n[0], s = Math.abs(i.pos - t);
    for (let a of n) {
      let l = Math.abs(a.pos - t);
      l < s && (s = l, i = a);
    }
    return i;
  }
  getPageBreakPositions(t, o) {
    let r = Array.from(o.querySelectorAll('.breaker:not([data-page-number="0"])'));
    if (console.log({ pageBreaks: r }), !r.length) return [];
    let n = t.getBoundingClientRect();
    return r.map((i) => i.getBoundingClientRect().bottom - n.top + t.scrollTop);
  }
  calculatePageForPosition(t, o, r, n, i = false) {
    try {
      let s = r.coordsAtPos(t), a = n.getBoundingClientRect(), l = s.top - a.top + n.scrollTop;
      i && console.log(`[PageTracker] calculatePageForPosition - pos: ${t}, positionTop: ${l}, pageBreakBottoms:`, o);
      let d = 1;
      for (let c = 0; c < o.length; c++) if (l >= o[c]) d = c + 2, i && console.log(`[PageTracker] positionTop ${l} >= pageBreakBottom[${c}] ${o[c]}, page = ${d}`);
      else {
        i && console.log(`[PageTracker] positionTop ${l} < pageBreakBottom[${c}] ${o[c]}, stopping at page ${d}`);
        break;
      }
      return i && console.log(`[PageTracker] Final calculated page: ${d}`), d;
    } catch (s) {
      return i && console.log(`[PageTracker] Error getting coordinates for pos ${t}, using fallback:`, s), this.estimatePageForPosition(t, o, r);
    }
  }
  calculateNodePage(t, o, r, n, i, s = false) {
    try {
      let a = n.coordsAtPos(o), l = i.getBoundingClientRect(), d = a.top - l.top + i.scrollTop;
      s && console.log(`[PageTracker] calculateNodePage - pos: ${o}, nodeTop: ${d}, pageBreakBottoms:`, r);
      let c = 1;
      for (let u = 0; u < r.length; u++) if (d >= r[u]) c = u + 2, s && console.log(`[PageTracker] nodeTop ${d} >= pageBreakBottom[${u}] ${r[u]}, page = ${c}`);
      else {
        s && console.log(`[PageTracker] nodeTop ${d} < pageBreakBottom[${u}] ${r[u]}, stopping at page ${c}`);
        break;
      }
      return s && console.log(`[PageTracker] Final calculated page: ${c}`), c;
    } catch (a) {
      return s && console.log(`[PageTracker] Error getting coordinates for pos ${o}, using fallback:`, a), this.estimateNodePage(t, o, r, n);
    }
  }
  estimatePageForPosition(t, o, r) {
    let n = r.dom.scrollHeight, i = t / r.state.doc.content.size * n, s = 1;
    for (let a = 0; a < o.length && i >= o[a]; a++) s = a + 2;
    return s;
  }
  estimateNodePage(t, o, r, n) {
    let i = n.dom.scrollHeight, s = o / n.state.doc.content.size * i, a = 1;
    for (let l = 0; l < r.length && s >= r[l]; l++) a = l + 2;
    return a;
  }
  getAllNodesOnSinglePage(t, o) {
    let r = [];
    return t.state.doc.descendants((n, i) => (n.isBlock && r.push({ node: n, pos: i, page: o }), true)), r;
  }
};
function hr() {
  let e = Date.now().toString(36), t = Math.random().toString(36).substring(2, 9);
  return `tiptap-pages-${e}-${t}`;
}
function mr(e) {
  return typeof e == "number" && Number.isFinite(e);
}
function dt(e) {
  return mr(e) && e >= 0;
}
function gr(e) {
  return mr(e) && e > 0;
}
function ws(e) {
  if (!e || typeof e != "object") return false;
  let t = e;
  return dt(t.top) && dt(t.right) && dt(t.bottom) && dt(t.left);
}
function Os(e) {
  if (!e || typeof e != "object") return { valid: false, code: "INVALID_TYPE", message: "Expected a page format object." };
  if (typeof e.id != "string" || e.id.trim().length === 0) return { valid: false, code: "INVALID_ID", message: "Page format id must be a non-empty string." };
  if (!gr(e.width)) return { valid: false, code: "INVALID_WIDTH", message: "Page width must be a positive finite number (pixels)." };
  if (!gr(e.height)) return { valid: false, code: "INVALID_HEIGHT", message: "Page height must be a positive finite number (pixels)." };
  if (!ws(e.margins)) return { valid: false, code: "INVALID_MARGINS", message: "Margins must be an object with non-negative finite numbers for top, right, bottom, and left (pixels)." };
  let t = e.width - (e.margins.left + e.margins.right), o = e.height - (e.margins.top + e.margins.bottom);
  return t <= 0 || o <= 0 ? { valid: false, code: "NEGATIVE_CONTENT_SIZE", message: "Sum of horizontal or vertical margins exceeds page dimensions, leaving no content area." } : { valid: true };
}
function As(e) {
  return typeof e == "string" ? Object.prototype.hasOwnProperty.call(Ce, e) ? { valid: true } : { valid: false, code: "UNKNOWN_PRESET", message: `Unknown page format preset: ${e}` } : Os(e);
}
function fr(e) {
  return As(e).valid;
}
var br = (e) => e.getMeta("unique-id-change") || e.getMeta("page-format-change") || e.getMeta("footer-change") || e.getMeta("header-change") || e.getMeta("page-gap-change") || e.getMeta("header-top-margin-change") || e.getMeta("footer-height-change") || e.getMeta("page-break-background-change");
var pt = Extension.create({ name: "pages", addOptions() {
  return { pageFormat: "A4", headerTopMargin: void 0, footerBottomMargin: void 0, pageGap: 50, footer: "", header: "", differentFirstPage: false, headerFirstPage: "", differentOddEven: false, headerOdd: "", headerEven: "", differentFirstPageFooter: false, footerFirstPage: "", differentOddEvenFooter: false, footerOdd: "", footerEven: "", onPageFormatChange: () => {
  }, pageBreakBackground: "#ffffff" };
}, addStorage() {
  var e, t, o, r, n, i, s, a, l, d, c, u;
  return { pageFormat: this.options.pageFormat, footer: this.options.footer, header: this.options.header, headerHTML: "", pageGap: (e = this.options.pageGap) != null ? e : 50, headerTopMargin: this.options.headerTopMargin, headerContentHeight: 0, headerFirstPageContentHeight: 0, headerOddContentHeight: 0, headerEvenContentHeight: 0, normalizedHeaderTemplate: null, differentFirstPage: (t = this.options.differentFirstPage) != null ? t : false, headerFirstPage: (o = this.options.headerFirstPage) != null ? o : "", headerFirstPageHTML: "", normalizedFirstPageTemplate: null, differentOddEven: (r = this.options.differentOddEven) != null ? r : false, headerOdd: (n = this.options.headerOdd) != null ? n : "", headerEven: (i = this.options.headerEven) != null ? i : "", headerOddHTML: "", headerEvenHTML: "", normalizedOddTemplate: null, normalizedEvenTemplate: null, footerBottomMargin: this.options.footerBottomMargin, footerHTML: "", footerContentHeight: 0, footerFirstPageContentHeight: 0, footerOddContentHeight: 0, footerEvenContentHeight: 0, normalizedFooterTemplate: null, differentFirstPageFooter: (s = this.options.differentFirstPageFooter) != null ? s : false, footerFirstPage: (a = this.options.footerFirstPage) != null ? a : "", footerFirstPageHTML: "", normalizedFirstPageFooterTemplate: null, differentOddEvenFooter: (l = this.options.differentOddEvenFooter) != null ? l : false, footerOdd: (d = this.options.footerOdd) != null ? d : "", footerEven: (c = this.options.footerEven) != null ? c : "", footerOddHTML: "", footerEvenHTML: "", normalizedOddFooterTemplate: null, normalizedEvenFooterTemplate: null, pageBreakBackground: (u = this.options.pageBreakBackground) != null ? u : "#ffffff", uniqueId: hr(), styleElement: null, pageTracker: new lt(), activeEditor: null, activeEditorType: null, activePageNumber: null };
}, onCreate() {
  let e = this.editor.view.state.tr.setMeta("unique-id-change", Date.now());
  this.editor.view.dispatch(e), H({ view: this.editor.view, options: this.options, storage: this.storage }), nr();
  let t = re.getInstance();
  rr();
  let o = oe.getInstance();
  this.options.headerFooterExtensions && this.options.headerFooterExtensions.length > 0 && (t.configureExtensions(this.options.headerFooterExtensions), o.configureExtensions(this.options.headerFooterExtensions)), this.editor.view.dom.addEventListener("dblclick", (r) => {
    let n = r.target, i = n.closest('.tiptap-page-header[data-editable="true"]');
    if (i) {
      r.preventDefault(), r.stopPropagation();
      let a = parseInt(i.dataset.headerPageNumber || "1", 10), l = i.dataset.headerType || "default", d = () => {
        switch (l) {
          case "first":
            return this.storage.headerFirstPageHTML || i.innerHTML;
          case "odd":
            return this.storage.headerOddHTML || i.innerHTML;
          case "even":
            return this.storage.headerEvenHTML || i.innerHTML;
          default:
            return this.storage.headerHTML || i.innerHTML;
        }
      }, c = (g) => {
        switch (l) {
          case "first":
            this.storage.headerFirstPageHTML = g;
            break;
          case "odd":
            this.storage.headerOddHTML = g;
            break;
          case "even":
            this.storage.headerEvenHTML = g;
            break;
          default:
            this.storage.headerHTML = g;
            break;
        }
      }, u = (g) => {
        switch (l) {
          case "first":
            this.storage.headerFirstPageContentHeight = g;
            break;
          case "odd":
            this.storage.headerOddContentHeight = g;
            break;
          case "even":
            this.storage.headerEvenContentHeight = g;
            break;
          default:
            this.storage.headerContentHeight = g;
            break;
        }
      }, h2 = () => {
        switch (l) {
          case "first":
            return this.storage.headerFirstPageContentHeight;
          case "odd":
            return this.storage.headerOddContentHeight;
          case "even":
            return this.storage.headerEvenContentHeight;
          default:
            return this.storage.headerContentHeight;
        }
      }, m = d(), f = N({ ...this.options, pageFormat: this.storage.pageFormat }), v = this.storage.headerTopMargin || f.headerTopMargin, T = f.margins.top - v;
      t.show(i, a, m, { headerType: l, baseMinHeight: T, onContentChange: () => {
        c(t.getHTML());
      }, onHeightChange: (g) => {
        let b = N({ ...this.options, pageFormat: this.storage.pageFormat }), x = this.storage.headerTopMargin || b.headerTopMargin, k = b.margins.top - x, P = Math.max(0, g - k);
        if (P !== h2()) {
          u(P);
          let M = this.editor.view.state.tr.setMeta("header-change", Date.now());
          this.editor.view.dispatch(M), H({ view: this.editor.view, options: this.options, storage: this.storage });
        }
      }, onClose: (g, b) => {
        c(t.getHTML()), this.storage.activeEditor = null, this.storage.activeEditorType = null, this.storage.activePageNumber = null;
        let x = N({ ...this.options, pageFormat: this.storage.pageFormat }), k = this.storage.headerTopMargin || x.headerTopMargin, P = x.margins.top - k, M = Math.max(0, b - P);
        u(M);
        let F = this.editor.view.state.tr.setMeta("header-change", Date.now());
        this.editor.view.dispatch(F), H({ view: this.editor.view, options: this.options, storage: this.storage }), this.editor.emit("update", { editor: this.editor, transaction: this.editor.state.tr, appendedTransactions: [] });
      } }), this.storage.activeEditor = t.getEditor(), this.storage.activeEditorType = "header", this.storage.activePageNumber = a, this.editor.emit("update", { editor: this.editor, transaction: this.editor.state.tr, appendedTransactions: [] });
      return;
    }
    let s = n.closest('.tiptap-page-footer[data-editable="true"]');
    if (s) {
      r.preventDefault(), r.stopPropagation();
      let a = parseInt(s.dataset.footerPageNumber || "1", 10), l = J(a, this.storage), d = () => {
        switch (l) {
          case "first":
            return this.storage.footerFirstPageHTML || s.innerHTML;
          case "odd":
            return this.storage.footerOddHTML || s.innerHTML;
          case "even":
            return this.storage.footerEvenHTML || s.innerHTML;
          default:
            return this.storage.footerHTML || s.innerHTML;
        }
      }, c = (g) => {
        switch (l) {
          case "first":
            this.storage.footerFirstPageHTML = g;
            break;
          case "odd":
            this.storage.footerOddHTML = g;
            break;
          case "even":
            this.storage.footerEvenHTML = g;
            break;
          default:
            this.storage.footerHTML = g;
            break;
        }
      }, u = (g) => {
        switch (l) {
          case "first":
            this.storage.footerFirstPageContentHeight = g;
            break;
          case "odd":
            this.storage.footerOddContentHeight = g;
            break;
          case "even":
            this.storage.footerEvenContentHeight = g;
            break;
          default:
            this.storage.footerContentHeight = g;
            break;
        }
      }, h2 = () => {
        switch (l) {
          case "first":
            return this.storage.footerFirstPageContentHeight;
          case "odd":
            return this.storage.footerOddContentHeight;
          case "even":
            return this.storage.footerEvenContentHeight;
          default:
            return this.storage.footerContentHeight;
        }
      }, m = d(), f = N({ ...this.options, pageFormat: this.storage.pageFormat }), v = this.storage.footerBottomMargin || f.footerBottomMargin, T = f.margins.bottom - v;
      o.show(s, a, m, { footerType: l, baseMinHeight: T, onContentChange: () => {
        c(o.getHTML());
      }, onHeightChange: (g) => {
        let b = N({ ...this.options, pageFormat: this.storage.pageFormat }), x = this.storage.footerBottomMargin || b.footerBottomMargin, k = b.margins.bottom - x, P = Math.max(0, g - k);
        if (P !== h2()) {
          u(P);
          let M = this.editor.view.state.tr.setMeta("footer-change", Date.now());
          this.editor.view.dispatch(M), H({ view: this.editor.view, options: this.options, storage: this.storage });
        }
      }, onClose: (g, b) => {
        c(o.getHTML()), this.storage.activeEditor = null, this.storage.activeEditorType = null, this.storage.activePageNumber = null;
        let x = N({ ...this.options, pageFormat: this.storage.pageFormat }), k = this.storage.footerBottomMargin || x.footerBottomMargin, P = x.margins.bottom - k, M = Math.max(0, b - P);
        u(M);
        let F = this.editor.view.state.tr.setMeta("footer-change", Date.now());
        this.editor.view.dispatch(F), H({ view: this.editor.view, options: this.options, storage: this.storage }), this.editor.emit("update", { editor: this.editor, transaction: this.editor.state.tr, appendedTransactions: [] });
      } }), this.storage.activeEditor = o.getEditor(), this.storage.activeEditorType = "footer", this.storage.activePageNumber = a, this.editor.emit("update", { editor: this.editor, transaction: this.editor.state.tr, appendedTransactions: [] });
    }
  }), this.storage.getCurrentPage = (r) => this.storage.pageTracker.getCurrentPage(this.editor.view, r), this.storage.getPageForPosition = (r) => this.storage.pageTracker.getPageForPosition(r, this.editor.view), this.storage.getNodesOnPage = (r) => this.storage.pageTracker.getNodesOnPage(r, this.editor.view), this.storage.getPageStats = () => this.storage.pageTracker.getPageStats(this.editor.view), this.storage.doesRangeSpanPages = (r, n) => this.storage.pageTracker.doesRangeSpanPages(r, n, this.editor.view), this.storage.getPageCount = () => this.storage.pageTracker.getPageCount(this.editor.view);
}, addCommands() {
  return { setPageFormat: (e) => () => {
    var o, r;
    if (!fr(e)) return console.warn("Rejected invalid page format input. No change applied."), false;
    this.storage.pageFormat = e;
    let t = this.editor.view.state.tr.setMeta("page-format-change", Date.now());
    return this.editor.view.dispatch(t), H({ view: this.editor.view, options: this.options, storage: this.storage }), (r = (o = this.options).onPageFormatChange) == null || r.call(o, e), true;
  }, setFooter: (e) => () => {
    this.storage.footer = e;
    let t = this.editor.view.state.tr.setMeta("footer-change", Date.now());
    return this.editor.view.dispatch(t), H({ view: this.editor.view, options: this.options, storage: this.storage }), true;
  }, setHeader: (e) => () => {
    this.storage.header = e;
    let t = this.editor.view.state.tr.setMeta("header-change", Date.now());
    return this.editor.view.dispatch(t), H({ view: this.editor.view, options: this.options, storage: this.storage }), true;
  }, setPageGap: (e) => () => {
    if (typeof e != "number" && (e = parseInt(e, 10)), e <= 0) return console.warn("Page gap must be greater than 0"), false;
    this.storage.pageGap = e;
    let t = this.editor.view.state.tr.setMeta("page-gap-change", Date.now());
    return this.editor.view.dispatch(t), H({ view: this.editor.view, options: this.options, storage: this.storage }), true;
  }, setHeaderTopMargin: (e = 0) => () => {
    if (typeof e != "number" && (e = parseFloat(e)), e < 0) return console.warn("Header top margin must be >= 0"), false;
    this.storage.headerTopMargin = e;
    let t = this.editor.view.state.tr.setMeta("header-top-margin-change", Date.now());
    return this.editor.view.dispatch(t), H({ view: this.editor.view, options: this.options, storage: this.storage }), true;
  }, setFooterBottomMargin: (e = 0) => () => {
    if (typeof e != "number" && (e = parseFloat(e)), e < 0) return console.warn("Footer bottom margin must be >= 0"), false;
    this.storage.footerBottomMargin = e;
    let t = this.editor.view.state.tr.setMeta("footer-bottom-margin-change", Date.now());
    return this.editor.view.dispatch(t), H({ view: this.editor.view, options: this.options, storage: this.storage }), true;
  }, setPageBreakBackground: (e) => () => {
    this.storage.pageBreakBackground = e;
    let t = this.editor.view.state.tr.setMeta("page-break-background-change", Date.now());
    return this.editor.view.dispatch(t), H({ view: this.editor.view, options: this.options, storage: this.storage }), true;
  }, setDifferentFirstPage: (e) => () => {
    this.storage.differentFirstPage = e, this.storage.differentFirstPageFooter = e, this.storage.normalizedFirstPageTemplate = null, this.storage.normalizedFirstPageFooterTemplate = null;
    let t = this.editor.view.state.tr.setMeta("header-change", Date.now());
    return this.editor.view.dispatch(t), H({ view: this.editor.view, options: this.options, storage: this.storage }), true;
  }, setHeaderFirstPage: (e) => () => {
    this.storage.headerFirstPage = e, this.storage.headerFirstPageHTML = "", this.storage.normalizedFirstPageTemplate = null;
    let t = this.editor.view.state.tr.setMeta("header-change", Date.now());
    return this.editor.view.dispatch(t), H({ view: this.editor.view, options: this.options, storage: this.storage }), true;
  }, setDifferentOddEven: (e) => () => {
    this.storage.differentOddEven = e, this.storage.differentOddEvenFooter = e, this.storage.normalizedOddTemplate = null, this.storage.normalizedEvenTemplate = null, this.storage.normalizedOddFooterTemplate = null, this.storage.normalizedEvenFooterTemplate = null;
    let t = this.editor.view.state.tr.setMeta("header-change", Date.now());
    return this.editor.view.dispatch(t), H({ view: this.editor.view, options: this.options, storage: this.storage }), true;
  }, setHeaderOdd: (e) => () => {
    this.storage.headerOdd = e, this.storage.headerOddHTML = "", this.storage.normalizedOddTemplate = null;
    let t = this.editor.view.state.tr.setMeta("header-change", Date.now());
    return this.editor.view.dispatch(t), H({ view: this.editor.view, options: this.options, storage: this.storage }), true;
  }, setHeaderEven: (e) => () => {
    this.storage.headerEven = e, this.storage.headerEvenHTML = "", this.storage.normalizedEvenTemplate = null;
    let t = this.editor.view.state.tr.setMeta("header-change", Date.now());
    return this.editor.view.dispatch(t), H({ view: this.editor.view, options: this.options, storage: this.storage }), true;
  }, setDifferentFirstPageFooter: (e) => () => {
    this.storage.differentFirstPageFooter = e, this.storage.normalizedFirstPageFooterTemplate = null;
    let t = this.editor.view.state.tr.setMeta("footer-change", Date.now());
    return this.editor.view.dispatch(t), H({ view: this.editor.view, options: this.options, storage: this.storage }), true;
  }, setFooterFirstPage: (e) => () => {
    this.storage.footerFirstPage = e, this.storage.footerFirstPageHTML = "", this.storage.normalizedFirstPageFooterTemplate = null;
    let t = this.editor.view.state.tr.setMeta("footer-change", Date.now());
    return this.editor.view.dispatch(t), H({ view: this.editor.view, options: this.options, storage: this.storage }), true;
  }, setDifferentOddEvenFooter: (e) => () => {
    this.storage.differentOddEvenFooter = e, this.storage.normalizedOddFooterTemplate = null, this.storage.normalizedEvenFooterTemplate = null;
    let t = this.editor.view.state.tr.setMeta("footer-change", Date.now());
    return this.editor.view.dispatch(t), H({ view: this.editor.view, options: this.options, storage: this.storage }), true;
  }, setFooterOdd: (e) => () => {
    this.storage.footerOdd = e, this.storage.footerOddHTML = "", this.storage.normalizedOddFooterTemplate = null;
    let t = this.editor.view.state.tr.setMeta("footer-change", Date.now());
    return this.editor.view.dispatch(t), H({ view: this.editor.view, options: this.options, storage: this.storage }), true;
  }, setFooterEven: (e) => () => {
    this.storage.footerEven = e, this.storage.footerEvenHTML = "", this.storage.normalizedEvenFooterTemplate = null;
    let t = this.editor.view.state.tr.setMeta("footer-change", Date.now());
    return this.editor.view.dispatch(t), H({ view: this.editor.view, options: this.options, storage: this.storage }), true;
  } };
}, onDestroy() {
  ur(), re.destroy(), oe.destroy(), this.storage.styleElement && this.storage.styleElement.parentNode && (this.storage.styleElement.parentNode.removeChild(this.storage.styleElement), this.storage.styleElement = null);
}, addProseMirrorPlugins() {
  let e = this.options, t = this.editor, o = this.storage;
  return [new Plugin({ key: new PluginKey("pagination"), state: { init(r, n) {
    let i = Gt({ state: n, options: e, storage: o });
    return DecorationSet.create(n.doc, i);
  }, apply(r, n, i, s) {
    let a = ce({ view: t.view, options: e, storage: o }), l = de(t.view);
    if (a !== l || br(r)) {
      let d = Gt({ state: s, options: e, storage: o, pageCount: a });
      return DecorationSet.create(s.doc, [...d]);
    }
    return n;
  } }, props: { decorations(r) {
    return this.getState(r);
  } } })];
} });
function Ns(e, t = 96) {
  return e * t;
}
export {
  Ce as PAGE_FORMATS,
  Or as PageKit,
  pt as Pages,
  ut as TableKit,
  E as cmToPixels,
  Ns as inchToPixels
};
//# sourceMappingURL=@tiptap-pro_extension-pages.js.map
